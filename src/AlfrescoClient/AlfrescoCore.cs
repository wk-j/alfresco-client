//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace AlfrescoClient.AlfrescoCore
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class Client 
    {
        private string _baseUrl = "/alfresco/api/-default-/public/alfresco/versions/1";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }
    
        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
    
        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>List comments</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentPaging> ListCommentsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListCommentsAsync(nodeId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List comments</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentPaging> ListCommentsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/comments?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** exists but does not identify a file or a folder, \nor the value of **maxItems** is invalid, or the value of **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission read comments on the node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="commentBodyCreate">The comment text. Note that you can also provide a list of comments.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentEntry> CreateCommentAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, CommentBody commentBodyCreate)
        {
            return CreateCommentAsync(nodeId, fields, commentBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="commentBodyCreate">The comment text. Note that you can also provide a list of comments.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentEntry> CreateCommentAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, CommentBody commentBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/comments?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(commentBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **commentBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to create a comment", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cannot comment on a node of this type", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** is locked and you are not the lock owner\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="commentId">The identifier of a comment.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="commentBodyUpdate">The JSON representing the comment to be updated.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CommentEntry> UpdateCommentAsync(string nodeId, string commentId, System.Collections.Generic.IEnumerable<string> fields, CommentBody commentBodyUpdate)
        {
            return UpdateCommentAsync(nodeId, commentId, fields, commentBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="commentId">The identifier of a comment.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="commentBodyUpdate">The JSON representing the comment to be updated.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CommentEntry> UpdateCommentAsync(string nodeId, string commentId, System.Collections.Generic.IEnumerable<string> fields, CommentBody commentBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (commentId == null)
                throw new System.ArgumentNullException("commentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/comments/{commentId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(commentBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CommentEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **commentBodyUpdate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to update a comment", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **commentId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** is locked and you are not the lock owner\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="commentId">The identifier of a comment.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteCommentAsync(string nodeId, string commentId)
        {
            return DeleteCommentAsync(nodeId, commentId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a comment</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="commentId">The identifier of a comment.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteCommentAsync(string nodeId, string commentId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (commentId == null)
                throw new System.ArgumentNullException("commentId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/comments/{commentId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{commentId}", System.Uri.EscapeDataString(ConvertToString(commentId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to delete a comment", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **commentId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** is locked and you are not the lock owner\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List ratings</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RatingPaging> ListRatingsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListRatingsAsync(nodeId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List ratings</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RatingPaging> ListRatingsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/ratings?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RatingPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="ratingBodyCreate">For "myRating" the type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar.
        /// 
        /// For example, to "like" a file the following body would be used:
        /// 
        /// ```JSON
        ///   {
        ///     "id": "likes",
        ///     "myRating": true
        ///   }
        /// ```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RatingEntry> CreateRatingAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, RatingBody ratingBodyCreate)
        {
            return CreateRatingAsync(nodeId, fields, ratingBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="ratingBodyCreate">For "myRating" the type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar.
        /// 
        /// For example, to "like" a file the following body would be used:
        /// 
        /// ```JSON
        ///   {
        ///     "id": "likes",
        ///     "myRating": true
        ///   }
        /// ```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RatingEntry> CreateRatingAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, RatingBody ratingBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/ratings?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ratingBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RatingEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **ratingBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cannot rate a node of this type", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="ratingId">The identifier of a rating.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RatingEntry> GetRatingAsync(string nodeId, string ratingId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetRatingAsync(nodeId, ratingId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="ratingId">The identifier of a rating.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RatingEntry> GetRatingAsync(string nodeId, string ratingId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (ratingId == null)
                throw new System.ArgumentNullException("ratingId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/ratings/{ratingId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{ratingId}", System.Uri.EscapeDataString(ConvertToString(ratingId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RatingEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: unknown rating scheme specified\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="ratingId">The identifier of a rating.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteRatingAsync(string nodeId, string ratingId)
        {
            return DeleteRatingAsync(nodeId, ratingId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a rating</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="ratingId">The identifier of a rating.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteRatingAsync(string nodeId, string ratingId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (ratingId == null)
                throw new System.ArgumentNullException("ratingId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/ratings/{ratingId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{ratingId}", System.Uri.EscapeDataString(ConvertToString(ratingId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: unknown rating scheme specified\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List tags for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagPaging> ListTagsForNodeAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListTagsForNodeAsync(nodeId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List tags for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagPaging> ListTagsForNodeAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/tags?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to read tags on the node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a tag for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="tagBodyCreate">The new tag</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagEntry> CreateTagForNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, TagBody tagBodyCreate)
        {
            return CreateTagForNodeAsync(nodeId, fields, tagBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a tag for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="tagBodyCreate">The new tag</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagEntry> CreateTagForNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, TagBody tagBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/tags?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **tagBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to create tags on the node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist       \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cannot tag a node of this type", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a tag from a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteTagFromNodeAsync(string nodeId, string tagId)
        {
            return DeleteTagFromNodeAsync(nodeId, tagId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a tag from a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteTagFromNodeAsync(string nodeId, string tagId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (tagId == null)
                throw new System.ArgumentNullException("tagId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/tags/{tagId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tagId}", System.Uri.EscapeDataString(ConvertToString(tagId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to delete the tag", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **tagId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a node</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="relativePath">A path relative to the **nodeId**. If you set this, 
        /// information is returned on the node resolved by this path.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> GetNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, string relativePath, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetNodeAsync(nodeId, include, relativePath, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a node</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="relativePath">A path relative to the **nodeId**. If you set this, 
        /// information is returned on the node resolved by this path.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> GetNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, string relativePath, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (relativePath != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("relativePath") + "=").Append(System.Uri.EscapeDataString(ConvertToString(relativePath, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to retrieve **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyUpdate">The node information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> UpdateNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyUpdate nodeBodyUpdate)
        {
            return UpdateNodeAsync(nodeId, include, fields, nodeBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyUpdate">The node information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> UpdateNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyUpdate nodeBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(nodeBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: the update request is invalid or **nodeId** is not a valid format or **nodeBodyUpdate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Updated name clashes with an existing node in the current parent folder", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception including a file name containing invalid characters", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="permanent">If **true** then the node is deleted permanently, without moving to the trashcan.
        /// Only the owner of the node or an admin can permanently delete the node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteNodeAsync(string nodeId, bool? permanent)
        {
            return DeleteNodeAsync(nodeId, permanent, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="permanent">If **true** then the node is deleted permanently, without moving to the trashcan.
        /// Only the owner of the node or an admin can permanently delete the node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteNodeAsync(string nodeId, bool? permanent, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (permanent != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("permanent") + "=").Append(System.Uri.EscapeDataString(ConvertToString(permanent, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** is locked and cannot be deleted\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List node children</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(isFolder=true)```
        /// 
        /// *   ```where=(isFile=true)```
        /// 
        /// *   ```where=(nodeType='my:specialNodeType')```
        /// 
        /// *   ```where=(nodeType='my:specialNodeType INCLUDESUBTYPES')```
        /// 
        /// *   ```where=(isPrimary=true)```
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```
        /// 
        /// *   ```where=(isPrimary=false and assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties
        /// * permissions</param>
        /// <param name="relativePath">Return information on children in the folder resolved by this path. The path is relative to **nodeId**.</param>
        /// <param name="includeSource">Also include **source** in addition to **entries** with folder information on the parent node – either the specified parent **nodeId**, or as resolved by **relativePath**.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeChildAssociationPaging> ListNodeChildrenAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> include, string relativePath, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListNodeChildrenAsync(nodeId, skipCount, maxItems, orderBy, where, include, relativePath, includeSource, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List node children</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(isFolder=true)```
        /// 
        /// *   ```where=(isFile=true)```
        /// 
        /// *   ```where=(nodeType='my:specialNodeType')```
        /// 
        /// *   ```where=(nodeType='my:specialNodeType INCLUDESUBTYPES')```
        /// 
        /// *   ```where=(isPrimary=true)```
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```
        /// 
        /// *   ```where=(isPrimary=false and assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties
        /// * permissions</param>
        /// <param name="relativePath">Return information on children in the folder resolved by this path. The path is relative to **nodeId**.</param>
        /// <param name="includeSource">Also include **source** in addition to **entries** with folder information on the parent node – either the specified parent **nodeId**, or as resolved by **relativePath**.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeChildAssociationPaging> ListNodeChildrenAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> include, string relativePath, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/children?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (relativePath != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("relativePath") + "=").Append(System.Uri.EscapeDataString(ConvertToString(relativePath, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSource != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSource") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSource, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeChildAssociationPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, **nodeId** is not a folder or **orderBy** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to retrieve children of **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a node</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="autoRename">If true, then  a name clash will cause an attempt to auto rename by finding a unique name using an integer suffix.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyCreate">The node information to create.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> CreateNodeAsync(string nodeId, bool? autoRename, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyCreate nodeBodyCreate)
        {
            return CreateNodeAsync(nodeId, autoRename, include, fields, nodeBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a node</summary>
        /// <param name="nodeId">The identifier of a node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="autoRename">If true, then  a name clash will cause an attempt to auto rename by finding a unique name using an integer suffix.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyCreate">The node information to create.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> CreateNodeAsync(string nodeId, bool? autoRename, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyCreate nodeBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/children?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (autoRename != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("autoRename") + "=").Append(System.Uri.EscapeDataString(ConvertToString(autoRename, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(nodeBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format or **nodeBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to create children of **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("New name clashes with an existing node in the current parent folder", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "413") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds individual file size limit configured for the network or system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "415") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content Type is not supported", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception including a file name containing invalid characters", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "507") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds overall storage quota limit configured for the network or system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Copy a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyCopy">The targetParentId and, optionally, a new name which should include the file extension.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> CopyNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyCopy nodeBodyCopy)
        {
            return CopyNodeAsync(nodeId, include, fields, nodeBodyCopy, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Copy a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyCopy">The targetParentId and, optionally, a new name which should include the file extension.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> CopyNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyCopy nodeBodyCopy, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/copy?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(nodeBodyCopy, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format or **nodeBodyCopy** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to copy **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("New name clashes with an existing node in the destination parent folder", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception including a file name containing invalid characters", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Lock a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyLock">Lock details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> LockNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyLock nodeBodyLock)
        {
            return LockNodeAsync(nodeId, include, fields, nodeBodyLock, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Lock a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyLock">Lock details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> LockNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyLock nodeBodyLock, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/lock?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(nodeBodyLock, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or **nodeBodyLock** is invalid,\nor a lock was attempted on a node that is not a file\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to lock **nodeId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** could not be locked\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Unlock a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> UnlockNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return UnlockNodeAsync(nodeId, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Unlock a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> UnlockNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/unlock?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to unlock **nodeId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** could not be unlocked\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Move a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyMove">The targetParentId and, optionally, a new name which should include the file extension.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> MoveNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyMove nodeBodyMove)
        {
            return MoveNodeAsync(nodeId, include, fields, nodeBodyMove, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Move a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="nodeBodyMove">The targetParentId and, optionally, a new name which should include the file extension.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> MoveNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, NodeBodyMove nodeBodyMove, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/move?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(nodeBodyMove, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or **targetParentId** is not a folder,\nor **nodeBodyMove** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to move **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("New name clashes with an existing node in the destination parent folder", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception including a file name containing invalid characters", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetNodeContentAsync(string nodeId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range)
        {
            return GetNodeContentAsync(nodeId, attachment, if_Modified_Since, range, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetNodeContentAsync(string nodeId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to retrieve content of **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="majorVersion">If **true**, create a major version.
        /// Setting this parameter also enables versioning of this node, if it is not already versioned.</param>
        /// <param name="comment">Add a version comment which will appear in version history.
        /// Setting this parameter also enables versioning of this node, if it is not already versioned.</param>
        /// <param name="name">Optional new name. This should include the file extension.
        /// The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |. 
        /// The character `.` must not be used at the end of the name.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="contentBodyUpdate">The binary content</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> UpdateNodeContentAsync(string nodeId, bool? majorVersion, string comment, string name, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.IO.Stream contentBodyUpdate)
        {
            return UpdateNodeContentAsync(nodeId, majorVersion, comment, name, include, fields, contentBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="majorVersion">If **true**, create a major version.
        /// Setting this parameter also enables versioning of this node, if it is not already versioned.</param>
        /// <param name="comment">Add a version comment which will appear in version history.
        /// Setting this parameter also enables versioning of this node, if it is not already versioned.</param>
        /// <param name="name">Optional new name. This should include the file extension.
        /// The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |. 
        /// The character `.` must not be used at the end of the name.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="contentBodyUpdate">The binary content</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> UpdateNodeContentAsync(string nodeId, bool? majorVersion, string comment, string name, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.IO.Stream contentBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (majorVersion != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("majorVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(majorVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (comment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("comment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(comment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (name != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(contentBodyUpdate);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/octet-stream");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Optional new name clashes with an existing node in the current parent folder", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "413") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds individual file size limit (configured for network/system)", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception including a file name containing invalid characters", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "507") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds overall storage quota limit configured for the network/system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create rendition</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionBodyCreate">The rendition "id".</param>
        /// <returns>Request accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task CreateRenditionAsync(string nodeId, RenditionBodyCreate renditionBodyCreate)
        {
            return CreateRenditionAsync(nodeId, renditionBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create rendition</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionBodyCreate">The rendition "id".</param>
        /// <returns>Request accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task CreateRenditionAsync(string nodeId, RenditionBodyCreate renditionBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/renditions");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(renditionBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format or is not a file\nor **renditionBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("All requested renditions already exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Renditions/thumbnails are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List renditions</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionPaging> ListRenditionsAsync(string nodeId, string where)
        {
            return ListRenditionsAsync(nodeId, where, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List renditions</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionPaging> ListRenditionsAsync(string nodeId, string where, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/renditions?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, is not a file, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get rendition information</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionEntry> GetRenditionAsync(string nodeId, string renditionId)
        {
            return GetRenditionAsync(nodeId, renditionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get rendition information</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionEntry> GetRenditionAsync(string nodeId, string renditionId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/renditions/{renditionId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get rendition content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <param name="placeholder">If **true** and there is no rendition for this **nodeId** and **renditionId**, 
        /// then the placeholder image for the mime type of this rendition is returned, rather 
        /// than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetRenditionContentAsync(string nodeId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, bool? placeholder)
        {
            return GetRenditionContentAsync(nodeId, renditionId, attachment, if_Modified_Since, range, placeholder, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get rendition content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <param name="placeholder">If **true** and there is no rendition for this **nodeId** and **renditionId**, 
        /// then the placeholder image for the mime type of this rendition is returned, rather 
        /// than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetRenditionContentAsync(string nodeId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, bool? placeholder, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/renditions/{renditionId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (placeholder != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("placeholder") + "=").Append(System.Uri.EscapeDataString(ConvertToString(placeholder, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create secondary child</summary>
        /// <param name="nodeId">The identifier of a parent node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="secondaryChildAssociationBodyCreate">The child node id and assoc type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ChildAssociationEntry> CreateSecondaryChildAssociationAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, ChildAssociationBody secondaryChildAssociationBodyCreate)
        {
            return CreateSecondaryChildAssociationAsync(nodeId, fields, secondaryChildAssociationBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create secondary child</summary>
        /// <param name="nodeId">The identifier of a parent node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="secondaryChildAssociationBodyCreate">The child node id and assoc type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ChildAssociationEntry> CreateSecondaryChildAssociationAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, ChildAssociationBody secondaryChildAssociationBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/secondary-children?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(secondaryChildAssociationBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ChildAssociationEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown, or the **nodeId** is not a valid format,\nor **secondaryChildAssociationBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to create secondary children of **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Parent **nodeId** or **childId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("An association of this assoc type already exists between these two nodes", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List secondary children</summary>
        /// <param name="nodeId">The identifier of a parent node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="where">Optionally filter the list by assocType. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="includeSource">Also include **source** (in addition to **entries**) with folder information on **nodeId**</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeChildAssociationPaging> ListSecondaryChildrenAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, int? skipCount, int? maxItems, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSecondaryChildrenAsync(nodeId, where, include, skipCount, maxItems, includeSource, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List secondary children</summary>
        /// <param name="nodeId">The identifier of a parent node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="where">Optionally filter the list by assocType. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="includeSource">Also include **source** (in addition to **entries**) with folder information on **nodeId**</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeChildAssociationPaging> ListSecondaryChildrenAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, int? skipCount, int? maxItems, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/secondary-children?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSource != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSource") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSource, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeChildAssociationPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown or the **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Parent **nodeId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete secondary child or children</summary>
        /// <param name="nodeId">The identifier of a parent node.</param>
        /// <param name="childId">The identifier of a child node.</param>
        /// <param name="assocType">Only delete associations of this type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSecondaryChildAssociationAsync(string nodeId, string childId, string assocType)
        {
            return DeleteSecondaryChildAssociationAsync(nodeId, childId, assocType, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete secondary child or children</summary>
        /// <param name="nodeId">The identifier of a parent node.</param>
        /// <param name="childId">The identifier of a child node.</param>
        /// <param name="assocType">Only delete associations of this type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSecondaryChildAssociationAsync(string nodeId, string childId, string assocType, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (childId == null)
                throw new System.ArgumentNullException("childId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/secondary-children/{childId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{childId}", System.Uri.EscapeDataString(ConvertToString(childId, System.Globalization.CultureInfo.InvariantCulture)));
            if (assocType != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("assocType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(assocType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown or you are trying to delete a primary **assocType**. \nUse delete node instead\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Parent **nodeId** or **childId** does not exist (with given assocType, if specified)", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List parents</summary>
        /// <param name="nodeId">The identifier of a child node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="where">Optionally filter the list by **assocType** and/or **isPrimary**. Here are some example filters:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```
        /// 
        /// *   ```where=(isPrimary=true)```
        /// 
        /// *   ```where=(isPrimary=false and assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="includeSource">Also include **source** (in addition to **entries**) with folder information on **nodeId**</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeAssociationPaging> ListParentsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, int? skipCount, int? maxItems, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListParentsAsync(nodeId, where, include, skipCount, maxItems, includeSource, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List parents</summary>
        /// <param name="nodeId">The identifier of a child node. You can also use one of these well-known aliases:
        /// * -my-
        /// * -shared-
        /// * -root-</param>
        /// <param name="where">Optionally filter the list by **assocType** and/or **isPrimary**. Here are some example filters:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```
        /// 
        /// *   ```where=(isPrimary=true)```
        /// 
        /// *   ```where=(isPrimary=false and assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="includeSource">Also include **source** (in addition to **entries**) with folder information on **nodeId**</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeAssociationPaging> ListParentsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, int? skipCount, int? maxItems, bool? includeSource, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/parents?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (includeSource != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeSource") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeSource, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeAssociationPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown or the **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Child **nodeId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create node association</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="associationBodyCreate">The target node id and assoc type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AssociationEntry> CreateAssociationAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, AssociationBody associationBodyCreate)
        {
            return CreateAssociationAsync(nodeId, fields, associationBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create node association</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="associationBodyCreate">The target node id and assoc type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AssociationEntry> CreateAssociationAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, AssociationBody associationBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/targets?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(associationBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AssociationEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown, or the **nodeId** is not a valid format,\nor **associationBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Source **nodeId** or **targetId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("An association of this assoc type already exists between these two nodes", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List target associations</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="where">Optionally filter the list by **assocType**. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeAssociationPaging> ListTargetAssociationsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListTargetAssociationsAsync(nodeId, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List target associations</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="where">Optionally filter the list by **assocType**. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeAssociationPaging> ListTargetAssociationsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/targets?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeAssociationPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown or the **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Source **nodeId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete node association(s)</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="targetId">The identifier of a target node.</param>
        /// <param name="assocType">Only delete associations of this type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAssociationAsync(string nodeId, string targetId, string assocType)
        {
            return DeleteAssociationAsync(nodeId, targetId, assocType, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete node association(s)</summary>
        /// <param name="nodeId">The identifier of a source node.</param>
        /// <param name="targetId">The identifier of a target node.</param>
        /// <param name="assocType">Only delete associations of this type.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAssociationAsync(string nodeId, string targetId, string assocType, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (targetId == null)
                throw new System.ArgumentNullException("targetId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/targets/{targetId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{targetId}", System.Uri.EscapeDataString(ConvertToString(targetId, System.Globalization.CultureInfo.InvariantCulture)));
            if (assocType != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("assocType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(assocType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **assocType** is unknown, or the **nodeId** is not a valid format, or **targetId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Source **nodeId** or **targetId** does not exist (with given assocType, if specified)", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List source associations</summary>
        /// <param name="nodeId">The identifier of a target node.</param>
        /// <param name="where">Optionally filter the list by **assocType**. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeAssociationPaging> ListSourceAssociationsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSourceAssociationsAsync(nodeId, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List source associations</summary>
        /// <param name="nodeId">The identifier of a target node.</param>
        /// <param name="where">Optionally filter the list by **assocType**. Here's an example:
        /// 
        /// *   ```where=(assocType='my:specialAssocType')```</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeAssociationPaging> ListSourceAssociationsAsync(string nodeId, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/sources?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeAssociationPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format or **assocType** is unknown\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Target **nodeId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List version history</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the version node. The following optional fields can be requested:
        /// * properties
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<VersionPaging> ListVersionHistoryAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, int? skipCount, int? maxItems)
        {
            return ListVersionHistoryAsync(nodeId, include, fields, skipCount, maxItems, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List version history</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the version node. The following optional fields can be requested:
        /// * properties
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<VersionPaging> ListVersionHistoryAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, int? skipCount, int? maxItems, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/versions?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VersionPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format            \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Target **nodeId** does not exist", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get version information</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<VersionEntry> GetVersionAsync(string nodeId, string versionId)
        {
            return GetVersionAsync(nodeId, versionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get version information</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<VersionEntry> GetVersionAsync(string nodeId, string versionId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (versionId == null)
                throw new System.ArgumentNullException("versionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/versions/{versionId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{versionId}", System.Uri.EscapeDataString(ConvertToString(versionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VersionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or it exists but does not identify a file, or **versionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **versionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a version</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteVersionAsync(string nodeId, string versionId)
        {
            return DeleteVersionAsync(nodeId, versionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a version</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteVersionAsync(string nodeId, string versionId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (versionId == null)
                throw new System.ArgumentNullException("versionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/versions/{versionId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{versionId}", System.Uri.EscapeDataString(ConvertToString(versionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or exists but does not identify a file, or **versionId** is invalid     \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete the versioned node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **versionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Cannot delete the last remaining version", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get version content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetVersionContentAsync(string nodeId, string versionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range)
        {
            return GetVersionContentAsync(nodeId, versionId, attachment, if_Modified_Since, range, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get version content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetVersionContentAsync(string nodeId, string versionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (versionId == null)
                throw new System.ArgumentNullException("versionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/versions/{versionId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{versionId}", System.Uri.EscapeDataString(ConvertToString(versionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file, or **versionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **versionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Revert a version</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="revertBody">Optionally, specify a version comment and whether this should be a major version, or not.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<VersionEntry> RevertVersionAsync(string nodeId, string versionId, System.Collections.Generic.IEnumerable<string> fields, RevertBody revertBody)
        {
            return RevertVersionAsync(nodeId, versionId, fields, revertBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Revert a version</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="versionId">The identifier of a version, ie. version label, within the version history of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="revertBody">Optionally, specify a version comment and whether this should be a major version, or not.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<VersionEntry> RevertVersionAsync(string nodeId, string versionId, System.Collections.Generic.IEnumerable<string> fields, RevertBody revertBody, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (versionId == null)
                throw new System.ArgumentNullException("versionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/versions/{versionId}/revert?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{versionId}", System.Uri.EscapeDataString(ConvertToString(versionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(revertBody, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<VersionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or it exists \nbut does not identify a file, or **versionId** is invalid,\nor **revertBody** invalid          \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to revert the versioned node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **versionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception trying to revert the node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Retrieve actions for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ActionDefinitionList> NodeActionsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields)
        {
            return NodeActionsAsync(nodeId, skipCount, maxItems, orderBy, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve actions for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ActionDefinitionList> NodeActionsAsync(string nodeId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/action-definitions?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ActionDefinitionList>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount** or **orderBy** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List deleted nodes</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties
        /// * permissions</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeletedNodesPaging> ListDeletedNodesAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> include)
        {
            return ListDeletedNodesAsync(skipCount, maxItems, include, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List deleted nodes</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties
        /// * permissions</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeletedNodesPaging> ListDeletedNodesAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> include, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeletedNodesPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeletedNodeEntry> GetDeletedNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include)
        {
            return GetDeletedNodeAsync(nodeId, include, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * association
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * permissions</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeletedNodeEntry> GetDeletedNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> include, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeletedNodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to view the deleted node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Permanently delete a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteDeletedNodeAsync(string nodeId)
        {
            return DeleteDeletedNodeAsync(nodeId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Permanently delete a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteDeletedNodeAsync(string nodeId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format          \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to permanently delete the deleted node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get deleted node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetDeletedNodeContentAsync(string nodeId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range)
        {
            return GetDeletedNodeContentAsync(nodeId, attachment, if_Modified_Since, range, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get deleted node content</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetDeletedNodeContentAsync(string nodeId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to retrieve content of **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Restore a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="deletedNodeBodyRestore">The targetParentId if the node is restored to a new location.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodeEntry> RestoreDeletedNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, DeletedNodeBodyRestore deletedNodeBodyRestore)
        {
            return RestoreDeletedNodeAsync(nodeId, fields, deletedNodeBodyRestore, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Restore a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="deletedNodeBodyRestore">The targetParentId if the node is restored to a new location.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodeEntry> RestoreDeletedNodeAsync(string nodeId, System.Collections.Generic.IEnumerable<string> fields, DeletedNodeBodyRestore deletedNodeBodyRestore, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}/restore?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(deletedNodeBodyRestore, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** or **targetNodeId** is not a valid format             \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to restore the deleted node or user does not have permission to the target node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist or the restore destination parent node does not exists\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Node name already exists in the restore destination", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception trying to restore the node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List renditions for a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionPaging> ListDeletedNodeRenditionsAsync(string nodeId, string where)
        {
            return ListDeletedNodeRenditionsAsync(nodeId, where, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List renditions for a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionPaging> ListDeletedNodeRenditionsAsync(string nodeId, string where, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}/renditions?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, is not a file, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get rendition information for a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionEntry> GetArchivedNodeRenditionAsync(string nodeId, string renditionId)
        {
            return GetArchivedNodeRenditionAsync(nodeId, renditionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get rendition information for a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionEntry> GetArchivedNodeRenditionAsync(string nodeId, string renditionId, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}/renditions/{renditionId}");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get rendition content of a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <param name="placeholder">If **true** and there is no rendition for this **nodeId** and **renditionId**,
        /// then the placeholder image for the mime type of this rendition is returned, rather
        /// than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetArchivedNodeRenditionContentAsync(string nodeId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, bool? placeholder)
        {
            return GetArchivedNodeRenditionContentAsync(nodeId, renditionId, attachment, if_Modified_Since, range, placeholder, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get rendition content of a deleted node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <param name="placeholder">If **true** and there is no rendition for this **nodeId** and **renditionId**,
        /// then the placeholder image for the mime type of this rendition is returned, rather
        /// than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetArchivedNodeRenditionContentAsync(string nodeId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, bool? placeholder, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/deleted-nodes/{nodeId}/renditions/{renditionId}/content?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (placeholder != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("placeholder") + "=").Append(System.Uri.EscapeDataString(ConvertToString(placeholder, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or is not a file, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** or **renditionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a new download</summary>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="downloadBodyCreate">The nodeIds the content of which will be zipped, which zip will be set as the content of our download node.</param>
        /// <returns>The request to create a download node was accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DownloadEntry> CreateDownloadAsync(System.Collections.Generic.IEnumerable<string> fields, DownloadBodyCreate downloadBodyCreate)
        {
            return CreateDownloadAsync(fields, downloadBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a new download</summary>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="downloadBodyCreate">The nodeIds the content of which will be zipped, which zip will be set as the content of our download node.</param>
        /// <returns>The request to create a download node was accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DownloadEntry> CreateDownloadAsync(System.Collections.Generic.IEnumerable<string> fields, DownloadBodyCreate downloadBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/downloads?");
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(downloadBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DownloadEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **DownloadBodyCreate** is invalid due to incorrect syntax, or **nodeIds** is empty, or **nodeIds** contains a duplicate **nodeId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to add a certain **nodeId** to the zip", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a download</summary>
        /// <param name="downloadId">The identifier of a download node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Download node information</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DownloadEntry> GetDownloadAsync(string downloadId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetDownloadAsync(downloadId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a download</summary>
        /// <param name="downloadId">The identifier of a download node.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Download node information</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DownloadEntry> GetDownloadAsync(string downloadId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (downloadId == null)
                throw new System.ArgumentNullException("downloadId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/downloads/{downloadId}?");
            urlBuilder_.Replace("{downloadId}", System.Uri.EscapeDataString(ConvertToString(downloadId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DownloadEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **downloadId** is invalid, or **downloadId** does not point to a node of download type\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to get information about **downloadId** node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Cancel a download</summary>
        /// <param name="downloadId">The identifier of a download node.</param>
        /// <returns>The request to cancel a download was accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task CancelDownloadAsync(string downloadId)
        {
            return CancelDownloadAsync(downloadId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Cancel a download</summary>
        /// <param name="downloadId">The identifier of a download node.</param>
        /// <returns>The request to cancel a download was accepted</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task CancelDownloadAsync(string downloadId, System.Threading.CancellationToken cancellationToken)
        {
            if (downloadId == null)
                throw new System.ArgumentNullException("downloadId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/downloads/{downloadId}");
            urlBuilder_.Replace("{downloadId}", System.Uri.EscapeDataString(ConvertToString(downloadId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **downloadId** is invalid, or **downloadId** does not point to a node of download type\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission cancel the **downloadId** node", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create person</summary>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="personBodyCreate">The person details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonEntry> CreatePersonAsync(System.Collections.Generic.IEnumerable<string> fields, PersonBodyCreate personBodyCreate)
        {
            return CreatePersonAsync(fields, personBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create person</summary>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="personBodyCreate">The person details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonEntry> CreatePersonAsync(System.Collections.Generic.IEnumerable<string> fields, PersonBodyCreate personBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people?");
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(personBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **personBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to create a person", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Person within given *id* already exists", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List people</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the person. The following optional fields can be requested:
        /// * properties
        /// * aspectNames
        /// * capabilities</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonPaging> ListPeopleAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListPeopleAsync(skipCount, maxItems, orderBy, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List people</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the person. The following optional fields can be requested:
        /// * properties
        /// * aspectNames
        /// * capabilities</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonPaging> ListPeopleAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount** or **orderBy** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a person</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonEntry> GetPersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetPersonAsync(personId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a person</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonEntry> GetPersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update person</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="personBodyUpdate">The person details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonEntry> UpdatePersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, PersonBodyUpdate personBodyUpdate)
        {
            return UpdatePersonAsync(personId, fields, personBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update person</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="personBodyUpdate">The person details.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonEntry> UpdatePersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, PersonBodyUpdate personBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(personBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: the update request is invalid or **personId** is not a valid format or **personBodyUpdate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update a person", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Model integrity exception", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List activities</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="who">A filter to include the user's activities only `me`, other user's activities only `others`'</param>
        /// <param name="siteId">Include only activity feed entries relating to this site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ActivityPaging> ListActivitiesForPersonAsync(string personId, int? skipCount, int? maxItems, string who, string siteId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListActivitiesForPersonAsync(personId, skipCount, maxItems, who, siteId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List activities</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="who">A filter to include the user's activities only `me`, other user's activities only `others`'</param>
        /// <param name="siteId">Include only activity feed entries relating to this site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ActivityPaging> ListActivitiesForPersonAsync(string personId, int? skipCount, int? maxItems, string who, string siteId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/activities?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (who != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("who") + "=").Append(System.Uri.EscapeDataString(ConvertToString(who, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (siteId != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("siteId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ActivityPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, or **who** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the activities for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List favorite sites</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SitePaging> ListFavoriteSitesForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListFavoriteSitesForPersonAsync(personId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List favorite sites</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SitePaging> ListFavoriteSitesForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorite-sites?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SitePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the favorite sites for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a site favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="favoriteSiteBodyCreate">The id of the site to favorite.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<FavoriteSiteEntry> CreateSiteFavoriteAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, FavoriteSiteBodyCreate favoriteSiteBodyCreate)
        {
            return CreateSiteFavoriteAsync(personId, fields, favoriteSiteBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a site favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="favoriteSiteBodyCreate">The id of the site to favorite.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<FavoriteSiteEntry> CreateSiteFavoriteAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, FavoriteSiteBodyCreate favoriteSiteBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorite-sites?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(favoriteSiteBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FavoriteSiteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **favoriteSiteBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the favorite sites for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**id** is already a site favorite\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a favorite site</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SiteEntry> GetFavoriteSiteAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetFavoriteSiteAsync(personId, siteId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a favorite site</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SiteEntry> GetFavoriteSiteAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorite-sites/{siteId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the favorite sites for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a site favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task DeleteSiteFavoriteAsync(string personId, string siteId)
        {
            return DeleteSiteFavoriteAsync(personId, siteId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a site favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task DeleteSiteFavoriteAsync(string personId, string siteId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorite-sites/{siteId}");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the favorite sites for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List favorites</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FavoritePaging> ListFavoritesAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListFavoritesAsync(personId, skipCount, maxItems, orderBy, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List favorites</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FavoritePaging> ListFavoritesAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorites?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FavoritePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, **orderBy**, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist or the current user does not have permission to access the favorites of **personId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="favoriteBodyCreate">An object identifying the entity to be favorited. 
        /// 
        /// The object consists of a single property which is an object with the name `site`, `file`, or `folder`. 
        /// The content of that object is the `guid` of the target entity.
        /// 
        /// For example, to favorite a file the following body would be used:
        /// 
        /// ```JSON
        /// {
        ///    "target": {
        ///       "file": {
        ///          "guid": "abcde-01234-...."
        ///       }
        ///    }
        /// }
        /// ```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FavoriteEntry> CreateFavoriteAsync(string personId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, FavoriteBodyCreate favoriteBodyCreate)
        {
            return CreateFavoriteAsync(personId, include, fields, favoriteBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="favoriteBodyCreate">An object identifying the entity to be favorited. 
        /// 
        /// The object consists of a single property which is an object with the name `site`, `file`, or `folder`. 
        /// The content of that object is the `guid` of the target entity.
        /// 
        /// For example, to favorite a file the following body would be used:
        /// 
        /// ```JSON
        /// {
        ///    "target": {
        ///       "file": {
        ///          "guid": "abcde-01234-...."
        ///       }
        ///    }
        /// }
        /// ```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FavoriteEntry> CreateFavoriteAsync(string personId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, FavoriteBodyCreate favoriteBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorites?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(favoriteBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FavoriteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **favoriteBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist, or the target entity does not exist,\nor a favorite already exists with the specified id, or an\nentity exists with the id of the posted object\nbut is not of the same type of the posted object\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The target **guid** has already been favorited", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="favoriteId">The identifier of a favorite.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FavoriteEntry> GetFavoriteAsync(string personId, string favoriteId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetFavoriteAsync(personId, favoriteId, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="favoriteId">The identifier of a favorite.</param>
        /// <param name="include">Returns additional information about favorites, the following optional fields can be requested:
        /// * path (note, this only applies to files and folders)
        /// * properties</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FavoriteEntry> GetFavoriteAsync(string personId, string favoriteId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (favoriteId == null)
                throw new System.ArgumentNullException("favoriteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorites/{favoriteId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{favoriteId}", System.Uri.EscapeDataString(ConvertToString(favoriteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FavoriteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **favoriteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="favoriteId">The identifier of a favorite.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteFavoriteAsync(string personId, string favoriteId)
        {
            return DeleteFavoriteAsync(personId, favoriteId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a favorite</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="favoriteId">The identifier of a favorite.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteFavoriteAsync(string personId, string favoriteId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (favoriteId == null)
                throw new System.ArgumentNullException("favoriteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/favorites/{favoriteId}");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{favoriteId}", System.Uri.EscapeDataString(ConvertToString(favoriteId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **favoriteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List network membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonNetworkPaging> ListNetworksForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListNetworksForPersonAsync(personId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List network membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonNetworkPaging> ListNetworksForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/networks?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonNetworkPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get network information</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="networkId">The identifier of a network.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonNetworkEntry> GetNetworkForPersonAsync(string personId, string networkId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetNetworkForPersonAsync(personId, networkId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get network information</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="networkId">The identifier of a network.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonNetworkEntry> GetNetworkForPersonAsync(string personId, string networkId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (networkId == null)
                throw new System.ArgumentNullException("networkId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/networks/{networkId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{networkId}", System.Uri.EscapeDataString(ConvertToString(networkId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonNetworkEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **networkId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List preferences</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PreferencePaging> ListPreferencesAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListPreferencesAsync(personId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List preferences</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PreferencePaging> ListPreferencesAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/preferences?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PreferencePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the preferences for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a preference</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="preferenceName">The name of the preference.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PreferenceEntry> GetPreferenceAsync(string personId, string preferenceName, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetPreferenceAsync(personId, preferenceName, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a preference</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="preferenceName">The name of the preference.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PreferenceEntry> GetPreferenceAsync(string personId, string preferenceName, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (preferenceName == null)
                throw new System.ArgumentNullException("preferenceName");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/preferences/{preferenceName}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{preferenceName}", System.Uri.EscapeDataString(ConvertToString(preferenceName, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PreferenceEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have access to the preferences for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **preferenceName** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List site membership requests</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMembershipRequestPaging> ListSiteMembershipRequestsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSiteMembershipRequestsForPersonAsync(personId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List site membership requests</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMembershipRequestPaging> ListSiteMembershipRequestsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/site-membership-requests?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMembershipRequestPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipRequestBodyCreate">Site membership request details</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMembershipRequestEntry> CreateSiteMembershipRequestForPersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipRequestBodyCreate siteMembershipRequestBodyCreate)
        {
            return CreateSiteMembershipRequestForPersonAsync(personId, fields, siteMembershipRequestBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipRequestBodyCreate">Site membership request details</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMembershipRequestEntry> CreateSiteMembershipRequestForPersonAsync(string personId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipRequestBodyCreate siteMembershipRequestBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/site-membership-requests?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipRequestBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMembershipRequestEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **id** is invalid, or the user is already invited,\nor **siteMembershipRequestBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **id** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMembershipRequestEntry> GetSiteMembershipRequestForPersonAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSiteMembershipRequestForPersonAsync(personId, siteId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMembershipRequestEntry> GetSiteMembershipRequestForPersonAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/site-membership-requests/{siteId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMembershipRequestEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipRequestBodyUpdate">The new message to display</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMembershipRequestEntry> UpdateSiteMembershipRequestForPersonAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipRequestBodyUpdate siteMembershipRequestBodyUpdate)
        {
            return UpdateSiteMembershipRequestForPersonAsync(personId, siteId, fields, siteMembershipRequestBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipRequestBodyUpdate">The new message to display</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMembershipRequestEntry> UpdateSiteMembershipRequestForPersonAsync(string personId, string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipRequestBodyUpdate siteMembershipRequestBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/site-membership-requests/{siteId}?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipRequestBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMembershipRequestEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **id** is invalid\nor **siteMembershipRequestBodyUpdate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSiteMembershipRequestForPersonAsync(string personId, string siteId)
        {
            return DeleteSiteMembershipRequestForPersonAsync(personId, siteId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a site membership request</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSiteMembershipRequestForPersonAsync(string personId, string siteId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/site-membership-requests/{siteId}");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List site memberships</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteRolePaging> ListSiteMembershipsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields, string where)
        {
            return ListSiteMembershipsForPersonAsync(personId, skipCount, maxItems, orderBy, relations, fields, where, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List site memberships</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteRolePaging> ListSiteMembershipsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields, string where, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/sites?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (relations != null) 
            {
                foreach (var item_ in relations) { urlBuilder_.Append(System.Uri.EscapeDataString("relations") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteRolePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, **orderBy**, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a site membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteRoleEntry> GetSiteMembershipForPersonAsync(string personId, string siteId)
        {
            return GetSiteMembershipForPersonAsync(personId, siteId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a site membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteRoleEntry> GetSiteMembershipForPersonAsync(string personId, string siteId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/sites/{siteId}");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteRoleEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a site membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSiteMembershipForPersonAsync(string personId, string siteId)
        {
            return DeleteSiteMembershipForPersonAsync(personId, siteId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a site membership</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="siteId">The identifier of a site.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSiteMembershipForPersonAsync(string personId, string siteId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/sites/{siteId}");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** or **siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List group memberships</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupPaging> ListGroupMembershipsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, string where, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListGroupMembershipsForPersonAsync(personId, skipCount, maxItems, orderBy, include, where, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List group memberships</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupPaging> ListGroupMembershipsForPersonAsync(string personId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, string where, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/groups?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, **orderBy** or **personId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Request password reset</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="clientBody">The client name to send email with app-specific url.</param>
        /// <returns>Successful response or even when the **personId** does not exist or the user is disabled by an Administrator</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task RequestPasswordResetAsync(string personId, ClientBody clientBody)
        {
            return RequestPasswordResetAsync(personId, clientBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Request password reset</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="clientBody">The client name to send email with app-specific url.</param>
        /// <returns>Successful response or even when the **personId** does not exist or the user is disabled by an Administrator</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task RequestPasswordResetAsync(string personId, ClientBody clientBody, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/request-password-reset");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(clientBody, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            return;
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**client** is not registered\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reset password</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="passwordResetBody">The reset password details</param>
        /// <returns>Successful response or even when no workflow instance is found with the given **id** or the workflow instance is
        /// invalid (already been used or expired) or the given **personId** does not match the person's id requesting
        /// the password reset or the given workflow **key** does not match the recovered key.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ResetPasswordAsync(string personId, PasswordResetBody passwordResetBody)
        {
            return ResetPasswordAsync(personId, passwordResetBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reset password</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="passwordResetBody">The reset password details</param>
        /// <returns>Successful response or even when no workflow instance is found with the given **id** or the workflow instance is
        /// invalid (already been used or expired) or the given **personId** does not match the person's id requesting
        /// the password reset or the given workflow **key** does not match the recovered key.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ResetPasswordAsync(string personId, PasswordResetBody passwordResetBody, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/reset-password");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(passwordResetBody, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: Value of **password**, **id** or **key** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="placeholder">If **true** and there is no avatar for this **personId** 
        /// then the placeholder image is returned, rather than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetAvatarImageAsync(string personId, bool? attachment, System.DateTimeOffset? if_Modified_Since, bool? placeholder)
        {
            return GetAvatarImageAsync(personId, attachment, if_Modified_Since, placeholder, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="placeholder">If **true** and there is no avatar for this **personId** 
        /// then the placeholder image is returned, rather than a 404 response.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetAvatarImageAsync(string personId, bool? attachment, System.DateTimeOffset? if_Modified_Since, bool? placeholder, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/avatar?");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (placeholder != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("placeholder") + "=").Append(System.Uri.EscapeDataString(ConvertToString(placeholder, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **personId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist or avatar does not exist (and no placeholder requested)\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="contentBodyUpdate">The binary content</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task UpdateAvatarImageAsync(string personId, System.IO.Stream contentBodyUpdate)
        {
            return UpdateAvatarImageAsync(personId, contentBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="contentBodyUpdate">The binary content</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task UpdateAvatarImageAsync(string personId, System.IO.Stream contentBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/avatar");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StreamContent(contentBodyUpdate);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/octet-stream");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **personId** is not a valid format or the avatar cannot be uploaded\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update the avatar image for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "413") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds individual file size limit (configured for network/system)", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Renditions/thumbnails are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "507") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content exceeds overall storage quota limit configured for the network/system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAvatarImageAsync(string personId)
        {
            return DeleteAvatarImageAsync(personId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete avatar image</summary>
        /// <param name="personId">The identifier of a person.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAvatarImageAsync(string personId, System.Threading.CancellationToken cancellationToken)
        {
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/people/{personId}/avatar");
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete the avatar image for **personId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List sites</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SitePaging> ListSitesAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields, string where)
        {
            return ListSitesAsync(skipCount, maxItems, orderBy, relations, fields, where, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List sites</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SitePaging> ListSitesAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields, string where, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (relations != null) 
            {
                foreach (var item_ in relations) { urlBuilder_.Append(System.Uri.EscapeDataString("relations") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SitePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, **orderBy**, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a site</summary>
        /// <param name="skipConfiguration">Flag to indicate whether the Share-specific (surf) configuration files for the site should not be created.</param>
        /// <param name="skipAddToFavorites">Flag to indicate whether the site should not be added to the user's site favorites.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteBodyCreate">The site details</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteEntry> CreateSiteAsync(bool? skipConfiguration, bool? skipAddToFavorites, System.Collections.Generic.IEnumerable<string> fields, SiteBodyCreate siteBodyCreate)
        {
            return CreateSiteAsync(skipConfiguration, skipAddToFavorites, fields, siteBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a site</summary>
        /// <param name="skipConfiguration">Flag to indicate whether the Share-specific (surf) configuration files for the site should not be created.</param>
        /// <param name="skipAddToFavorites">Flag to indicate whether the site should not be added to the user's site favorites.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteBodyCreate">The site details</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteEntry> CreateSiteAsync(bool? skipConfiguration, bool? skipAddToFavorites, System.Collections.Generic.IEnumerable<string> fields, SiteBodyCreate siteBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites?");
            if (skipConfiguration != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipConfiguration") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipConfiguration, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (skipAddToFavorites != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipAddToFavorites") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipAddToFavorites, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **id**, **title**, or **description** exceed the maximum length; \nor **id** contains invalid characters; or **siteBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Site with the given identifier already exists", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteEntry> GetSiteAsync(string siteId, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSiteAsync(siteId, relations, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="relations">Use the relations parameter to include one or more related entities in a single response.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteEntry> GetSiteAsync(string siteId, System.Collections.Generic.IEnumerable<string> relations, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (relations != null) 
            {
                foreach (var item_ in relations) { urlBuilder_.Append(System.Uri.EscapeDataString("relations") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteBodyUpdate">The site information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteEntry> UpdateSiteAsync(string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteBodyUpdate siteBodyUpdate)
        {
            return UpdateSiteAsync(siteId, fields, siteBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteBodyUpdate">The site information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteEntry> UpdateSiteAsync(string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteBodyUpdate siteBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **siteBodyUpdate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update the site that is visible to them.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="permanent">Flag to indicate whether the site should be permanently deleted i.e. bypass the trashcan.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSiteAsync(string siteId, bool? permanent)
        {
            return DeleteSiteAsync(siteId, permanent, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a site</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="permanent">Flag to indicate whether the site should be permanently deleted i.e. bypass the trashcan.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSiteAsync(string siteId, bool? permanent, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (permanent != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("permanent") + "=").Append(System.Uri.EscapeDataString(ConvertToString(permanent, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete the site that is visible to them.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List site containers</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteContainerPaging> ListSiteContainersAsync(string siteId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSiteContainersAsync(siteId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List site containers</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteContainerPaging> ListSiteContainersAsync(string siteId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/containers?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteContainerPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a site container</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="containerId">The unique identifier of a site container.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteContainerEntry> GetSiteContainerAsync(string siteId, string containerId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSiteContainerAsync(siteId, containerId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a site container</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="containerId">The unique identifier of a site container.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteContainerEntry> GetSiteContainerAsync(string siteId, string containerId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (containerId == null)
                throw new System.ArgumentNullException("containerId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/containers/{containerId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{containerId}", System.Uri.EscapeDataString(ConvertToString(containerId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteContainerEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **containerId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get site membership requests</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMembershipRequestWithPersonPaging> GetSiteMembershipRequestsAsync(int? skipCount, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSiteMembershipRequestsAsync(skipCount, maxItems, where, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get site membership requests</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMembershipRequestWithPersonPaging> GetSiteMembershipRequestsAsync(int? skipCount, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/site-membership-requests?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMembershipRequestWithPersonPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Approve a site membership request</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="inviteeId">The invitee user name.</param>
        /// <param name="siteMembershipApprovalBody">Accepting a request to join, optionally, allows assignment of a role to the user.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ApproveSiteMembershipRequestAsync(string siteId, string inviteeId, SiteMembershipApprovalBody siteMembershipApprovalBody)
        {
            return ApproveSiteMembershipRequestAsync(siteId, inviteeId, siteMembershipApprovalBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Approve a site membership request</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="inviteeId">The invitee user name.</param>
        /// <param name="siteMembershipApprovalBody">Accepting a request to join, optionally, allows assignment of a role to the user.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ApproveSiteMembershipRequestAsync(string siteId, string inviteeId, SiteMembershipApprovalBody siteMembershipApprovalBody, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (inviteeId == null)
                throw new System.ArgumentNullException("inviteeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/site-membership-requests/{inviteeId}/approve");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{inviteeId}", System.Uri.EscapeDataString(ConvertToString(inviteeId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipApprovalBody, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **siteId** or **inviteeId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to approve membership request", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **inviteeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Integrity exception or not allowed to approve membership request.\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Reject a site membership request</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="inviteeId">The invitee user name.</param>
        /// <param name="siteMembershipRejectionBody">Rejecting a request to join, optionally, allows the inclusion of comment.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task RejectSiteMembershipRequestAsync(string siteId, string inviteeId, SiteMembershipRejectionBody siteMembershipRejectionBody)
        {
            return RejectSiteMembershipRequestAsync(siteId, inviteeId, siteMembershipRejectionBody, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reject a site membership request</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="inviteeId">The invitee user name.</param>
        /// <param name="siteMembershipRejectionBody">Rejecting a request to join, optionally, allows the inclusion of comment.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task RejectSiteMembershipRequestAsync(string siteId, string inviteeId, SiteMembershipRejectionBody siteMembershipRejectionBody, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (inviteeId == null)
                throw new System.ArgumentNullException("inviteeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/site-membership-requests/{inviteeId}/reject");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{inviteeId}", System.Uri.EscapeDataString(ConvertToString(inviteeId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipRejectionBody, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **siteId** or **inviteeId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to reject membership request", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Integrity exception or not allowed to reject membership request.\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **inviteeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List site memberships</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMemberPaging> ListSiteMembershipsAsync(string siteId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSiteMembershipsAsync(siteId, skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List site memberships</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMemberPaging> ListSiteMembershipsAsync(string siteId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/members?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMemberPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipBodyCreate">The person to add and their role</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMemberEntry> CreateSiteMembershipAsync(string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipBodyCreate siteMembershipBodyCreate)
        {
            return CreateSiteMembershipAsync(siteId, fields, siteMembershipBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipBodyCreate">The person to add and their role</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMemberEntry> CreateSiteMembershipAsync(string siteId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipBodyCreate siteMembershipBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/members?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMemberEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **role** or **id** is invalid\nor **siteMembershipBodyCreate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to invite a person", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Person with this **id** is already a member", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMemberEntry> GetSiteMembershipAsync(string siteId, string personId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSiteMembershipAsync(siteId, personId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMemberEntry> GetSiteMembershipAsync(string siteId, string personId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/members/{personId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMemberEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipBodyUpdate">The persons new role</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SiteMemberEntry> UpdateSiteMembershipAsync(string siteId, string personId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipBodyUpdate siteMembershipBodyUpdate)
        {
            return UpdateSiteMembershipAsync(siteId, personId, fields, siteMembershipBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="siteMembershipBodyUpdate">The persons new role</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SiteMemberEntry> UpdateSiteMembershipAsync(string siteId, string personId, System.Collections.Generic.IEnumerable<string> fields, SiteMembershipBodyUpdate siteMembershipBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/members/{personId}?");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(siteMembershipBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SiteMemberEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **role** does not exist\nor **siteMembershipBodyUpdate** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Integrity exception (eg. last site member must be a site manager) or not allowed to update member", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSiteMembershipAsync(string siteId, string personId)
        {
            return DeleteSiteMembershipAsync(siteId, personId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a site membership</summary>
        /// <param name="siteId">The identifier of a site.</param>
        /// <param name="personId">The identifier of a person.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSiteMembershipAsync(string siteId, string personId, System.Threading.CancellationToken cancellationToken)
        {
            if (siteId == null)
                throw new System.ArgumentNullException("siteId");
    
            if (personId == null)
                throw new System.ArgumentNullException("personId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/sites/{siteId}/members/{personId}");
            urlBuilder_.Replace("{siteId}", System.Uri.EscapeDataString(ConvertToString(siteId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{personId}", System.Uri.EscapeDataString(ConvertToString(personId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**siteId** or **personId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "422") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Integrity exception (eg. last site member must be a site manager) or not allowed to delete member", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List tags</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="include">Returns additional information about the tag. The following optional fields can be requested:
        /// * count</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagPaging> ListTagsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> include)
        {
            return ListTagsAsync(skipCount, maxItems, fields, include, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List tags</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="include">Returns additional information about the tag. The following optional fields can be requested:
        /// * count</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagPaging> ListTagsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> include, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/tags?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a tag</summary>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagEntry> GetTagAsync(string tagId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetTagAsync(tagId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a tag</summary>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagEntry> GetTagAsync(string tagId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (tagId == null)
                throw new System.ArgumentNullException("tagId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/tags/{tagId}?");
            urlBuilder_.Replace("{tagId}", System.Uri.EscapeDataString(ConvertToString(tagId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**tagId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update a tag</summary>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="tagBodyUpdate">The updated tag</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagEntry> UpdateTagAsync(string tagId, System.Collections.Generic.IEnumerable<string> fields, TagBody tagBodyUpdate)
        {
            return UpdateTagAsync(tagId, fields, tagBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update a tag</summary>
        /// <param name="tagId">The identifier of a tag.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="tagBodyUpdate">The updated tag</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagEntry> UpdateTagAsync(string tagId, System.Collections.Generic.IEnumerable<string> fields, TagBody tagBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (tagId == null)
                throw new System.ArgumentNullException("tagId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/tags/{tagId}?");
            urlBuilder_.Replace("{tagId}", System.Uri.EscapeDataString(ConvertToString(tagId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **tagBodyUpdate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**tagId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a network</summary>
        /// <param name="networkId">The identifier of a network.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonNetworkEntry> GetNetworkAsync(string networkId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetNetworkAsync(networkId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a network</summary>
        /// <param name="networkId">The identifier of a network.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonNetworkEntry> GetNetworkAsync(string networkId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (networkId == null)
                throw new System.ArgumentNullException("networkId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/networks/{networkId}?");
            urlBuilder_.Replace("{networkId}", System.Uri.EscapeDataString(ConvertToString(networkId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonNetworkEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**networkId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a shared link to a file</summary>
        /// <param name="include">Returns additional information about the shared link, the following optional fields can be requested:
        /// * allowableOperations
        /// * path
        /// * properties
        /// * isFavorite
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="sharedLinkBodyCreate">The nodeId to create a shared link for.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SharedLinkEntry> CreateSharedLinkAsync(System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, SharedLinkBodyCreate sharedLinkBodyCreate)
        {
            return CreateSharedLinkAsync(include, fields, sharedLinkBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a shared link to a file</summary>
        /// <param name="include">Returns additional information about the shared link, the following optional fields can be requested:
        /// * allowableOperations
        /// * path
        /// * properties
        /// * isFavorite
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="sharedLinkBodyCreate">The nodeId to create a shared link for.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SharedLinkEntry> CreateSharedLinkAsync(System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, SharedLinkBodyCreate sharedLinkBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links?");
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(sharedLinkBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SharedLinkEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **nodeId** is not a valid format, or does not identify a file,\nor **sharedLinkBodyCreate** invalid, or the specified expiry date is invalid. E.g. the expiry date\nhas already passed\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to create **sharedId** (for example, no read permission)", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared link already exists for **nodeId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List shared links</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list by "sharedByUser" userid of person who shared the link (can also use -me-)
        /// 
        /// *   ```where=(sharedByUser='jbloggs')```
        /// 
        /// *   ```where=(sharedByUser='-me-')```</param>
        /// <param name="include">Returns additional information about the shared link, the following optional fields can be requested:
        /// * allowableOperations
        /// * path
        /// * properties
        /// * isFavorite
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SharedLinkPaging> ListSharedLinksAsync(int? skipCount, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListSharedLinksAsync(skipCount, maxItems, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List shared links</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list by "sharedByUser" userid of person who shared the link (can also use -me-)
        /// 
        /// *   ```where=(sharedByUser='jbloggs')```
        /// 
        /// *   ```where=(sharedByUser='-me-')```</param>
        /// <param name="include">Returns additional information about the shared link, the following optional fields can be requested:
        /// * allowableOperations
        /// * path
        /// * properties
        /// * isFavorite
        /// * aspectNames</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SharedLinkPaging> ListSharedLinksAsync(int? skipCount, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SharedLinkPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid         \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SharedLinkEntry> GetSharedLinkAsync(string sharedId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetSharedLinkAsync(sharedId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SharedLinkEntry> GetSharedLinkAsync(string sharedId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}?");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SharedLinkEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Deletes a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteSharedLinkAsync(string sharedId)
        {
            return DeleteSharedLinkAsync(sharedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteSharedLinkAsync(string sharedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete **sharedId**", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get shared link content</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetSharedLinkContentAsync(string sharedId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range)
        {
            return GetSharedLinkContentAsync(sharedId, attachment, if_Modified_Since, range, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get shared link content</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetSharedLinkContentAsync(string sharedId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}/content?");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List renditions for a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionPaging> ListSharedLinkRenditionsAsync(string sharedId)
        {
            return ListSharedLinkRenditionsAsync(sharedId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List renditions for a shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionPaging> ListSharedLinkRenditionsAsync(string sharedId, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}/renditions");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get shared link rendition information</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RenditionEntry> GetSharedLinkRenditionAsync(string sharedId, string renditionId)
        {
            return GetSharedLinkRenditionAsync(sharedId, renditionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get shared link rendition information</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RenditionEntry> GetSharedLinkRenditionAsync(string sharedId, string renditionId, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}/renditions/{renditionId}");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RenditionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId**  or **renditionId** does not exist (ie. not CREATED)\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get shared link rendition content</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> GetSharedLinkRenditionContentAsync(string sharedId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range)
        {
            return GetSharedLinkRenditionContentAsync(sharedId, renditionId, attachment, if_Modified_Since, range, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get shared link rendition content</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="renditionId">The name of a thumbnail rendition, for example *doclib*, or *pdf*.</param>
        /// <param name="attachment">**true** enables a web browser to download the file as an attachment.
        /// **false** means a web browser may preview the file in a new tab or window, but not
        /// download the file.
        /// 
        /// You can only set this parameter to **false** if the content type of the file is in the supported list;
        /// for example, certain image files and PDF files.
        /// 
        /// If the content type is not supported for preview, then a value of **false**  is ignored, and
        /// the attachment will be returned in the response.</param>
        /// <param name="if_Modified_Since">Only returns the content if it has been modified since the date provided.
        /// Use the date format defined by HTTP. For example, `Wed, 09 Mar 2016 16:56:34 GMT`.</param>
        /// <param name="range">The Range header indicates the part of a document that the server should return.
        /// Single part request supported, for example: bytes=1-10.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> GetSharedLinkRenditionContentAsync(string sharedId, string renditionId, bool? attachment, System.DateTimeOffset? if_Modified_Since, string range, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            if (renditionId == null)
                throw new System.ArgumentNullException("renditionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}/renditions/{renditionId}/content?");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{renditionId}", System.Uri.EscapeDataString(ConvertToString(renditionId, System.Globalization.CultureInfo.InvariantCulture)));
            if (attachment != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("attachment") + "=").Append(System.Uri.EscapeDataString(ConvertToString(attachment, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (if_Modified_Since != null)
                        request_.Headers.TryAddWithoutValidation("If-Modified-Since", ConvertToString(if_Modified_Since, System.Globalization.CultureInfo.InvariantCulture));
                    if (range != null)
                        request_.Headers.TryAddWithoutValidation("Range", ConvertToString(range, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/octet-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == "206") 
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "304") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Content has not been modified since the date provided in the If-Modified-Since header", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format, or **renditionId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "416") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Range Not Satisfiable", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Email shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="sharedLinkBodyEmail">The shared link email to send.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task EmailSharedLinkAsync(string sharedId, SharedLinkBodyEmail sharedLinkBodyEmail)
        {
            return EmailSharedLinkAsync(sharedId, sharedLinkBodyEmail, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Email shared link</summary>
        /// <param name="sharedId">The identifier of a shared link to a file.</param>
        /// <param name="sharedLinkBodyEmail">The shared link email to send.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task EmailSharedLinkAsync(string sharedId, SharedLinkBodyEmail sharedLinkBodyEmail, System.Threading.CancellationToken cancellationToken)
        {
            if (sharedId == null)
                throw new System.ArgumentNullException("sharedId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/shared-links/{sharedId}/email");
            urlBuilder_.Replace("{sharedId}", System.Uri.EscapeDataString(ConvertToString(sharedId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(sharedLinkBodyEmail, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **sharedId** is not a valid format\nor **sharedLinkBodyEmail** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**sharedId** does not exist or **client** is not registered\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Shared links are disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Check readiness and liveness of the repository</summary>
        /// <param name="probeId">The name of the probe:
        /// * -ready-
        /// * -live-</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProbeEntry> GetProbeAsync(string probeId)
        {
            return GetProbeAsync(probeId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Check readiness and liveness of the repository</summary>
        /// <param name="probeId">The name of the probe:
        /// * -ready-
        /// * -live-</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProbeEntry> GetProbeAsync(string probeId, System.Threading.CancellationToken cancellationToken)
        {
            if (probeId == null)
                throw new System.ArgumentNullException("probeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/probes/{probeId}");
            urlBuilder_.Replace("{probeId}", System.Uri.EscapeDataString(ConvertToString(probeId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProbeEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**probeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "503") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Service Unavailable - Probe failure status.", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Find nodes</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="rootNodeId">The id of the node to start the search from.
        /// 
        /// Supports the aliases -my-, -root- and -shared-.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="nodeType">Restrict the returned results to only those of the given node type and its sub-types</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<NodePaging> FindNodesAsync(string term, string rootNodeId, int? skipCount, int? maxItems, string nodeType, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields)
        {
            return FindNodesAsync(term, rootNodeId, skipCount, maxItems, nodeType, include, orderBy, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Find nodes</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="rootNodeId">The id of the node to start the search from.
        /// 
        /// Supports the aliases -my-, -root- and -shared-.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="nodeType">Restrict the returned results to only those of the given node type and its sub-types</param>
        /// <param name="include">Returns additional information about the node. The following optional fields can be requested:
        /// * allowableOperations
        /// * aspectNames
        /// * isLink
        /// * isFavorite
        /// * isLocked
        /// * path
        /// * properties</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<NodePaging> FindNodesAsync(string term, string rootNodeId, int? skipCount, int? maxItems, string nodeType, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (term == null)
                throw new System.ArgumentNullException("term");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/queries/nodes?");
            urlBuilder_.Append(System.Uri.EscapeDataString("term") + "=").Append(System.Uri.EscapeDataString(ConvertToString(term, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (rootNodeId != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("rootNodeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(rootNodeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (nodeType != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("nodeType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(nodeType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<NodePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid, or search **term** too short, or **nodeType** unknown, or **orderBy** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**rootNodeId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Find sites</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SitePaging> FindSitesAsync(string term, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields)
        {
            return FindSitesAsync(term, skipCount, maxItems, orderBy, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Find sites</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SitePaging> FindSitesAsync(string term, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (term == null)
                throw new System.ArgumentNullException("term");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/queries/sites?");
            urlBuilder_.Append(System.Uri.EscapeDataString("term") + "=").Append(System.Uri.EscapeDataString(ConvertToString(term, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SitePaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid, or search **term** too short, or **orderBy** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Find people</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<PersonPaging> FindPeopleAsync(string term, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> orderBy)
        {
            return FindPeopleAsync(term, skipCount, maxItems, fields, orderBy, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Find people</summary>
        /// <param name="term">The term to search for.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<PersonPaging> FindPeopleAsync(string term, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> orderBy, System.Threading.CancellationToken cancellationToken)
        {
            if (term == null)
                throw new System.ArgumentNullException("term");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/queries/people?");
            urlBuilder_.Append(System.Uri.EscapeDataString("term") + "=").Append(System.Uri.EscapeDataString(ConvertToString(term, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PersonPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid, or search **term** too short, or **orderBy** invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List groups</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupPaging> ListGroupsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, string where, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListGroupsAsync(skipCount, maxItems, orderBy, include, where, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List groups</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupPaging> ListGroupsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> include, string where, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount**, or **orderBy**, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a group</summary>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupBodyCreate">The group to create.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupEntry> CreateGroupAsync(System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, GroupBodyCreate groupBodyCreate)
        {
            return CreateGroupAsync(include, fields, groupBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a group</summary>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupBodyCreate">The group to create.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupEntry> CreateGroupAsync(System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, GroupBodyCreate groupBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups?");
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(groupBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: invalid **groupBodyCreate**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to create a group", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**parentIds** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**id** clashes with an existing group\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get group details</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupEntry> GetGroupAsync(string groupId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetGroupAsync(groupId, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get group details</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupEntry> GetGroupAsync(string groupId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}?");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: invalid **groupId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update group details</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupBodyUpdate">The group information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupEntry> UpdateGroupAsync(string groupId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, GroupBodyUpdate groupBodyUpdate)
        {
            return UpdateGroupAsync(groupId, include, fields, groupBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update group details</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="include">Returns additional information about the group. The following optional fields can be requested:
        /// * parentIds
        /// * zones</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupBodyUpdate">The group information to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupEntry> UpdateGroupAsync(string groupId, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, GroupBodyUpdate groupBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}?");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(groupBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **groupId** or **groupBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to update a group", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Trying to modify a pre-defined system group, such as GROUP_EVERYONE\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a group</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="cascade">If **true** then the delete will be applied in cascade to sub-groups.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteGroupAsync(string groupId, bool? cascade)
        {
            return DeleteGroupAsync(groupId, cascade, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a group</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="cascade">If **true** then the delete will be applied in cascade to sub-groups.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteGroupAsync(string groupId, bool? cascade, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}?");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            if (cascade != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("cascade") + "=").Append(System.Uri.EscapeDataString(ConvertToString(cascade, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **groupId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to delete a group member", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Trying to delete a pre-defined system group, such as GROUP_EVERYONE.\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Create a group membership</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupMembershipBodyCreate">The group membership to add (person or sub-group).</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupMemberEntry> CreateGroupMembershipAsync(string groupId, System.Collections.Generic.IEnumerable<string> fields, GroupMembershipBodyCreate groupMembershipBodyCreate)
        {
            return CreateGroupMembershipAsync(groupId, fields, groupMembershipBodyCreate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Create a group membership</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="groupMembershipBodyCreate">The group membership to add (person or sub-group).</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupMemberEntry> CreateGroupMembershipAsync(string groupId, System.Collections.Generic.IEnumerable<string> fields, GroupMembershipBodyCreate groupMembershipBodyCreate, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}/members?");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(groupMembershipBodyCreate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupMemberEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **groupId** or **groupMembershipBodyCreate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to create a group membership", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** or *id* (of group or person) does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Trying to modify a pre-defined system group, such as GROUP_EVERYONE.\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List memberships of a group</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GroupMemberPaging> ListGroupMembershipsAsync(string groupId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListGroupMembershipsAsync(groupId, skipCount, maxItems, orderBy, where, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List memberships of a group</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="where">A string to restrict the returned objects by using a predicate.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GroupMemberPaging> ListGroupMembershipsAsync(string groupId, int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, string where, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}/members?");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GroupMemberPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount**, **orderBy**, or **where** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Trying to list all members of a pre-defined system group, such as GROUP_EVERYONE\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Delete a group membership</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="groupMemberId">The identifier of a person or group.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteGroupMembershipAsync(string groupId, string groupMemberId)
        {
            return DeleteGroupMembershipAsync(groupId, groupMemberId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a group membership</summary>
        /// <param name="groupId">The identifier of a group.</param>
        /// <param name="groupMemberId">The identifier of a person or group.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteGroupMembershipAsync(string groupId, string groupMemberId, System.Threading.CancellationToken cancellationToken)
        {
            if (groupId == null)
                throw new System.ArgumentNullException("groupId");
    
            if (groupMemberId == null)
                throw new System.ArgumentNullException("groupMemberId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/groups/{groupId}/members/{groupMemberId}");
            urlBuilder_.Replace("{groupId}", System.Uri.EscapeDataString(ConvertToString(groupId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{groupMemberId}", System.Uri.EscapeDataString(ConvertToString(groupMemberId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **groupId**, or **groupMemberId** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to delete a group membership", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**groupId** or **groupMemberId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "409") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Trying to delete a member of a pre-defined system group, such as GROUP_EVERYONE\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List audit applications</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditAppPaging> ListAuditAppsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListAuditAppsAsync(skipCount, maxItems, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List audit applications</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditAppPaging> ListAuditAppsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditAppPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems** or **skipCount** is invalid            \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to retrieve audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get audit application info</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="include">Also include the current minimum and/or maximum audit entry ids for the application. The following optional fields can be requested:
        /// * max
        /// * min</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditApp> GetAuditAppAsync(string auditApplicationId, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> include)
        {
            return GetAuditAppAsync(auditApplicationId, fields, include, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get audit application info</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="include">Also include the current minimum and/or maximum audit entry ids for the application. The following optional fields can be requested:
        /// * max
        /// * min</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditApp> GetAuditAppAsync(string auditApplicationId, System.Collections.Generic.IEnumerable<string> fields, System.Collections.Generic.IEnumerable<string> include, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}?");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditApp>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: invalid **auditApplicationId**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to retrieve audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**applicationId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Update audit application info</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="auditAppBodyUpdate">The audit application to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditApp> UpdateAuditAppAsync(string auditApplicationId, System.Collections.Generic.IEnumerable<string> fields, AuditBodyUpdate auditAppBodyUpdate)
        {
            return UpdateAuditAppAsync(auditApplicationId, fields, auditAppBodyUpdate, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Update audit application info</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <param name="auditAppBodyUpdate">The audit application to update.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditApp> UpdateAuditAppAsync(string auditApplicationId, System.Collections.Generic.IEnumerable<string> fields, AuditBodyUpdate auditAppBodyUpdate, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}?");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(auditAppBodyUpdate, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditApp>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **auditApplicationId** is not a valid format or **auditAppBodyUpdate** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to update audit application", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**auditApplicationId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List audit entries for an audit application</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(createdByUser='jbloggs')```
        /// 
        /// *   ```where=(id BETWEEN ('1234', '4321')```
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(createdByUser='jbloggs' and createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(valuesKey='/alfresco-access/login/user')```
        /// 
        /// *   ```where=(valuesKey='/alfresco-access/transaction/action' and valuesValue='DELETE')```</param>
        /// <param name="include">Returns additional information about the audit entry. The following optional fields can be requested:
        /// * values</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditEntryPaging> ListAuditEntriesForAuditAppAsync(string auditApplicationId, int? skipCount, System.Collections.Generic.IEnumerable<string> orderBy, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListAuditEntriesForAuditAppAsync(auditApplicationId, skipCount, orderBy, maxItems, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List audit entries for an audit application</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(createdByUser='jbloggs')```
        /// 
        /// *   ```where=(id BETWEEN ('1234', '4321')```
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(createdByUser='jbloggs' and createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(valuesKey='/alfresco-access/login/user')```
        /// 
        /// *   ```where=(valuesKey='/alfresco-access/transaction/action' and valuesValue='DELETE')```</param>
        /// <param name="include">Returns additional information about the audit entry. The following optional fields can be requested:
        /// * values</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditEntryPaging> ListAuditEntriesForAuditAppAsync(string auditApplicationId, int? skipCount, System.Collections.Generic.IEnumerable<string> orderBy, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}/audit-entries?");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditEntryPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: *auditApplicationId** is not a valid format, value of **maxItems** or **skipCount** is invalid            \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to retrieve audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**applicationId** does not exist          \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Permanently delete audit entries for an audit application</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="where">Audit entries to permanently delete for an audit application, given an inclusive time period or range of ids. For example:
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// *   ```where=(id BETWEEN ('1234', '4321')```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAuditEntriesForAuditAppAsync(string auditApplicationId, string where)
        {
            return DeleteAuditEntriesForAuditAppAsync(auditApplicationId, where, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Permanently delete audit entries for an audit application</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="where">Audit entries to permanently delete for an audit application, given an inclusive time period or range of ids. For example:
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// *   ```where=(id BETWEEN ('1234', '4321')```</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAuditEntriesForAuditAppAsync(string auditApplicationId, string where, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            if (where == null)
                throw new System.ArgumentNullException("where");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}/audit-entries?");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **auditApplicationId** is not a valid format or invalid **where**\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**auditApplicationId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get audit entry</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="auditEntryId">The identifier of an audit entry.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditEntryEntry> GetAuditEntryAsync(string auditApplicationId, string auditEntryId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return GetAuditEntryAsync(auditApplicationId, auditEntryId, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get audit entry</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="auditEntryId">The identifier of an audit entry.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditEntryEntry> GetAuditEntryAsync(string auditApplicationId, string auditEntryId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            if (auditEntryId == null)
                throw new System.ArgumentNullException("auditEntryId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}/audit-entries/{auditEntryId}?");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{auditEntryId}", System.Uri.EscapeDataString(ConvertToString(auditEntryId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditEntryEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **auditApplicationId** or **auditEntryId** is not a valid format            \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to retrieve audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**auditApplicationId** or **auditEntryId** does not exist          \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Permanently delete an audit entry</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="auditEntryId">The identifier of an audit entry.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task DeleteAuditEntryAsync(string auditApplicationId, string auditEntryId)
        {
            return DeleteAuditEntryAsync(auditApplicationId, auditEntryId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Permanently delete an audit entry</summary>
        /// <param name="auditApplicationId">The identifier of an audit application.</param>
        /// <param name="auditEntryId">The identifier of an audit entry.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task DeleteAuditEntryAsync(string auditApplicationId, string auditEntryId, System.Threading.CancellationToken cancellationToken)
        {
            if (auditApplicationId == null)
                throw new System.ArgumentNullException("auditApplicationId");
    
            if (auditEntryId == null)
                throw new System.ArgumentNullException("auditEntryId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/audit-applications/{auditApplicationId}/audit-entries/{auditEntryId}");
            urlBuilder_.Replace("{auditApplicationId}", System.Uri.EscapeDataString(ConvertToString(auditApplicationId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{auditEntryId}", System.Uri.EscapeDataString(ConvertToString(auditEntryId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "204") 
                        {
                            return;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **auditApplicationId** or **auditEntryId** is not a valid format\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Current user does not have permission to delete audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**auditApplicationId** or **auditEntryId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>List audit entries for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(createdByUser='-me-')```
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(createdByUser='jbloggs' and createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```</param>
        /// <param name="include">Returns additional information about the audit entry. The following optional fields can be requested:
        /// * values</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditEntryPaging> ListAuditEntriesForNodeAsync(string nodeId, int? skipCount, System.Collections.Generic.IEnumerable<string> orderBy, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListAuditEntriesForNodeAsync(nodeId, skipCount, orderBy, maxItems, where, include, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>List audit entries for a node</summary>
        /// <param name="nodeId">The identifier of a node.</param>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="where">Optionally filter the list. Here are some examples:
        /// 
        /// *   ```where=(createdByUser='-me-')```
        /// 
        /// *   ```where=(createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```
        /// 
        /// *   ```where=(createdByUser='jbloggs' and createdAt BETWEEN ('2017-06-02T12:13:51.593+01:00' , '2017-06-04T10:05:16.536+01:00')```</param>
        /// <param name="include">Returns additional information about the audit entry. The following optional fields can be requested:
        /// * values</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditEntryPaging> ListAuditEntriesForNodeAsync(string nodeId, int? skipCount, System.Collections.Generic.IEnumerable<string> orderBy, int? maxItems, string where, System.Collections.Generic.IEnumerable<string> include, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            if (nodeId == null)
                throw new System.ArgumentNullException("nodeId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/nodes/{nodeId}/audit-entries?");
            urlBuilder_.Replace("{nodeId}", System.Uri.EscapeDataString(ConvertToString(nodeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (where != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("where") + "=").Append(System.Uri.EscapeDataString(ConvertToString(where, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (include != null) 
            {
                foreach (var item_ in include) { urlBuilder_.Append(System.Uri.EscapeDataString("include") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditEntryPaging>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: *nodeId** is not a valid format, value of **maxItems** or **skipCount** is invalid            \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("User does not have permission to retrieve audit information", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**nodeId** does not exist          \n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "501") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Audit is disabled for the system", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Retrieve list of available actions</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ActionDefinitionList> ListActionsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields)
        {
            return ListActionsAsync(skipCount, maxItems, orderBy, fields, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve list of available actions</summary>
        /// <param name="skipCount">The number of entities that exist in the collection before those included in this list. 
        /// If not supplied then the default value is 0.</param>
        /// <param name="maxItems">The maximum number of items to return in the list. 
        /// If not supplied then the default value is 100.</param>
        /// <param name="orderBy">A string to control the order of the entities returned in a list. You can use the **orderBy** parameter to
        /// sort the list by one or more fields.
        /// 
        /// Each field has a default sort order, which is normally ascending order. Read the API method implementation notes
        /// above to check if any fields used in this method have a descending default search order.
        /// 
        /// To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field.</param>
        /// <param name="fields">A list of field names.
        /// 
        /// You can use this parameter to restrict the fields
        /// returned within a response if, for example, you want to save on overall bandwidth.
        /// 
        /// The list applies to a returned individual
        /// entity or entries within a collection.
        /// 
        /// If the API method also supports the **include**
        /// parameter, then the fields specified in the **include**
        /// parameter are returned in addition to those specified in the **fields** parameter.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ActionDefinitionList> ListActionsAsync(int? skipCount, int? maxItems, System.Collections.Generic.IEnumerable<string> orderBy, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/action-definitions?");
            if (skipCount != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("skipCount") + "=").Append(System.Uri.EscapeDataString(ConvertToString(skipCount, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (maxItems != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("maxItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(maxItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (orderBy != null) 
            {
                foreach (var item_ in orderBy) { urlBuilder_.Append(System.Uri.EscapeDataString("orderBy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (fields != null) 
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ActionDefinitionList>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: value of **maxItems**, **skipCount** or **orderBy** is invalid\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Retrieve the details of an action definition</summary>
        /// <param name="actionDefinitionId">The identifier of an action definition.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ActionDefinitionEntry> ActionDetailsAsync(string actionDefinitionId)
        {
            return ActionDetailsAsync(actionDefinitionId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieve the details of an action definition</summary>
        /// <param name="actionDefinitionId">The identifier of an action definition.</param>
        /// <returns>Successful response</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ActionDefinitionEntry> ActionDetailsAsync(string actionDefinitionId, System.Threading.CancellationToken cancellationToken)
        {
            if (actionDefinitionId == null)
                throw new System.ArgumentNullException("actionDefinitionId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/action-definitions/{actionDefinitionId}");
            urlBuilder_.Replace("{actionDefinitionId}", System.Uri.EscapeDataString(ConvertToString(actionDefinitionId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ActionDefinitionEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**actionDefinitionId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Execute an action</summary>
        /// <param name="actionBodyExec">Action execution details</param>
        /// <returns>Action execution request accepted and pending execution.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ActionExecResultEntry> ActionExecAsync(ActionBodyExec actionBodyExec)
        {
            return ActionExecAsync(actionBodyExec, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Execute an action</summary>
        /// <param name="actionBodyExec">Action execution details</param>
        /// <returns>Action execution request accepted and pending execution.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ActionExecResultEntry> ActionExecAsync(ActionBodyExec actionBodyExec, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/action-executions");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(actionBodyExec, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "202") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ActionExecResultEntry>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Invalid parameter: **actionDefinitionId** missing but required by the action\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Authentication failed", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("**actionDefinitionId** or **targetId** does not exist\n", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<Error>("Unexpected error", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Error 
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Error1 Error1 { get; set; } = new Error1();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Pagination 
    {
        /// <summary>The number of objects in the entries array.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public long Count { get; set; }
    
        /// <summary>A boolean value which is **true** if there are more entities in the collection
        /// beyond those in this response. A true value means a request with a larger value
        /// for the **skipCount** or the **maxItems** parameter will return more entities.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hasMoreItems", Required = Newtonsoft.Json.Required.Always)]
        public bool HasMoreItems { get; set; }
    
        /// <summary>An integer describing the total number of entities in the collection.
        /// The API might not be able to determine this value,
        /// in which case this property will not be present.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("totalItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TotalItems { get; set; }
    
        /// <summary>An integer describing how many entities exist in the collection before
        /// those included in this list. If there was no **skipCount** parameter then the 
        /// default value is 0.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("skipCount", Required = Newtonsoft.Json.Required.Always)]
        public long SkipCount { get; set; }
    
        /// <summary>The value of the **maxItems** parameter used to generate this list.
        /// If there was no **maxItems** parameter then the default value is 100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxItems", Required = Newtonsoft.Json.Required.Always)]
        public long MaxItems { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("visibility", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteBodyCreateVisibility Visibility { get; set; } = AlfrescoClient.AlfrescoCore.SiteBodyCreateVisibility.PUBLIC;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SitePaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List List { get; set; } = new List();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Site Entry { get; set; } = new Site();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Site 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Guid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("visibility", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteVisibility Visibility { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Preset { get; set; }
    
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteRole2? Role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("visibility", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteBodyUpdateVisibility? Visibility { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteContainerPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List2 List { get; set; } = new List2();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteContainerEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SiteContainer Entry { get; set; } = new SiteContainer();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteContainer 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("folderId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FolderId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteMembershipBodyCreateRole Role { get; set; }
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteMembershipBodyUpdateRole Role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMemberPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List3 List { get; set; } = new List3();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMemberEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SiteMember Entry { get; set; } = new SiteMember();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMember 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("person", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Person Person { get; set; } = new Person();
    
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteMemberRole Role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteRolePaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List4 List { get; set; } = new List4();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteRoleEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SiteRole Entry { get; set; } = new SiteRole();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteRole 
    {
        [Newtonsoft.Json.JsonProperty("site", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Site Site { get; set; } = new Site();
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Guid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SiteRoleRole Role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FirstName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("skypeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SkypeId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("googleId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GoogleId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("instantMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstantMessageId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobTitle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobTitle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }
    
        [Newtonsoft.Json.JsonProperty("company", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Company Company { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mobile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mobile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("telephone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Telephone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserStatus { get; set; }
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("emailNotificationsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EmailNotificationsEnabled { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FirstName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("skypeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SkypeId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("googleId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GoogleId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("instantMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstantMessageId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobTitle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobTitle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }
    
        [Newtonsoft.Json.JsonProperty("company", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Company Company { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mobile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mobile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("telephone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Telephone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserStatus { get; set; }
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("emailNotificationsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EmailNotificationsEnabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }
    
        [Newtonsoft.Json.JsonProperty("oldPassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OldPassword { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List5 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Person Entry { get; set; } = new Person();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Person 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("firstName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FirstName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lastName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LastName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avatarId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AvatarId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("skypeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SkypeId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("googleId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GoogleId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("instantMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstantMessageId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobTitle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobTitle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }
    
        [Newtonsoft.Json.JsonProperty("company", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Company Company { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mobile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mobile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("telephone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Telephone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("statusUpdatedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StatusUpdatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UserStatus { get; set; }
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("emailNotificationsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EmailNotificationsEnabled { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Capabilities { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Company 
    {
        [Newtonsoft.Json.JsonProperty("organization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Organization { get; set; }
    
        [Newtonsoft.Json.JsonProperty("address1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address1 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("address2", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address2 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("address3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address3 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("postcode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Postcode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("telephone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Telephone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fax { get; set; }
    
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List6 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Group Entry { get; set; } = new Group();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Group 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isRoot", Required = Newtonsoft.Json.Required.Always)]
        public bool IsRoot { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("parentIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ParentIds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("zones", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Zones { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupMemberPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List7 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupMemberEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public GroupMember Entry { get; set; } = new GroupMember();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupMember 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("memberType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GroupMemberMemberType MemberType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupMembershipBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("memberType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public GroupMembershipBodyCreateMemberType MemberType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("parentIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ParentIds { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class GroupBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class CommentBody 
    {
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Content { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class CommentPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List8 List { get; set; } = new List8();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class CommentEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Comment Entry { get; set; } = new Comment();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Comment 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Content { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Person CreatedBy { get; set; } = new Person();
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("edited", Required = Newtonsoft.Json.Required.Always)]
        public bool Edited { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedBy", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Person ModifiedBy { get; set; } = new Person();
    
        [Newtonsoft.Json.JsonProperty("modifiedAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ModifiedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("canEdit", Required = Newtonsoft.Json.Required.Always)]
        public bool CanEdit { get; set; }
    
        [Newtonsoft.Json.JsonProperty("canDelete", Required = Newtonsoft.Json.Required.Always)]
        public bool CanDelete { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class TagBody 
    {
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tag { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class TagPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List9 List { get; set; } = new List9();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class TagEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Tag Entry { get; set; } = new Tag();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Tag 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tag1 { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonNetworkPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List10 List { get; set; } = new List10();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonNetworkEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PersonNetwork Entry { get; set; } = new PersonNetwork();
    
    
    }
    
    /// <summary>A network is the group of users and sites that belong to an organization.
    /// Networks are organized by email domain. When a user signs up for an
    /// Alfresco account , their email domain becomes their Home Network.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PersonNetwork 
    {
        /// <summary>This network's unique id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        /// <summary>Is this the home network?</summary>
        [Newtonsoft.Json.JsonProperty("homeNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HomeNetwork { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Always)]
        public bool IsEnabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("paidNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PaidNetwork { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subscriptionLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersonNetworkSubscriptionLevel? SubscriptionLevel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("quotas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkQuota> Quotas { get; set; }
    
    
    }
    
    /// <summary>Limits and usage of each quota. A network will have quotas for File space,
    /// the number of sites in the network, the number of people in the network,
    /// and the number of network administrators
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NetworkQuota 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.Always)]
        public long Limit { get; set; }
    
        [Newtonsoft.Json.JsonProperty("usage", Required = Newtonsoft.Json.Required.Always)]
        public long Usage { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RatingBody 
    {
        /// <summary>The rating scheme type. Possible values are likes and fiveStar.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RatingBodyId Id { get; set; } = AlfrescoClient.AlfrescoCore.RatingBodyId.Likes;
    
        /// <summary>The rating. The type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar</summary>
        [Newtonsoft.Json.JsonProperty("myRating", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MyRating { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RatingPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List11 List { get; set; } = new List11();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RatingEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Rating Entry { get; set; } = new Rating();
    
    
    }
    
    /// <summary>A person can rate an item of content by liking it. They can also remove
    /// their like of an item of content. API methods exist to get a list of
    /// ratings and to add a new rating.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Rating 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aggregate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Aggregate Aggregate { get; set; } = new Aggregate();
    
        [Newtonsoft.Json.JsonProperty("ratedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? RatedAt { get; set; }
    
        /// <summary>The rating. The type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar.</summary>
        [Newtonsoft.Json.JsonProperty("myRating", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MyRating { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoriteBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Target { get; set; } = new object();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoritePaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List12 List { get; set; } = new List12();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoriteEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Favorite Entry { get; set; } = new Favorite();
    
    
    }
    
    /// <summary>A favorite describes an Alfresco entity that a person has marked as a favorite.
    /// The target can be a site, file or folder.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Favorite 
    {
        /// <summary>The guid of the object that is a favorite.</summary>
        [Newtonsoft.Json.JsonProperty("targetGuid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetGuid { get; set; }
    
        /// <summary>The time the object was made a favorite.</summary>
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Target { get; set; } = new object();
    
        /// <summary>A subset of the target favorite properties, system properties and properties already available in the target are excluded.</summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoriteSiteBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoriteSiteEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public FavoriteSite Entry { get; set; } = new FavoriteSite();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class FavoriteSite 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActivityPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List13 List { get; set; } = new List13();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActivityEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Activity Entry { get; set; } = new Activity();
    
    
    }
    
    /// <summary>Activities describe any past activity in a site,
    /// for example creating an item of content, commenting on a node,
    /// liking an item of content.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Activity 
    {
        /// <summary>The id of the person who performed the activity</summary>
        [Newtonsoft.Json.JsonProperty("postPersonId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PostPersonId { get; set; }
    
        /// <summary>The unique id of the activity</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public long Id { get; set; }
    
        /// <summary>The unique id of the site on which the activity was performed</summary>
        [Newtonsoft.Json.JsonProperty("siteId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SiteId { get; set; }
    
        /// <summary>The date time at which the activity was performed</summary>
        [Newtonsoft.Json.JsonProperty("postedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? PostedAt { get; set; }
    
        /// <summary>The feed on which this activity was posted</summary>
        [Newtonsoft.Json.JsonProperty("feedPersonId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FeedPersonId { get; set; }
    
        /// <summary>An object summarizing the activity</summary>
        [Newtonsoft.Json.JsonProperty("activitySummary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ActivitySummary { get; set; }
    
        /// <summary>The type of the activity posted</summary>
        [Newtonsoft.Json.JsonProperty("activityType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ActivityType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PreferencePaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List14 List { get; set; } = new List14();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PreferenceEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Preference Entry { get; set; } = new Preference();
    
    
    }
    
    /// <summary>A specific preference.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Preference 
    {
        /// <summary>The unique id of the preference</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        /// <summary>The value of the preference. Note that this can be of any JSON type.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List15 List { get; set; } = new List15();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SiteMembershipRequest Entry { get; set; } = new SiteMembershipRequest();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequest 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("site", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Site Site { get; set; } = new Site();
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestWithPersonPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List16 List { get; set; } = new List16();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestWithPersonEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SiteMembershipRequestWithPerson Entry { get; set; } = new SiteMembershipRequestWithPerson();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRequestWithPerson 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("site", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Site Site { get; set; } = new Site();
    
        [Newtonsoft.Json.JsonProperty("person", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Person Person { get; set; } = new Person();
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipApprovalBody 
    {
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SiteMembershipRejectionBody 
    {
        [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Comment { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class UserInfo 
    {
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DisplayName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ContentInfo 
    {
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MimeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mimeTypeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MimeTypeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sizeInBytes", Required = Newtonsoft.Json.Required.Always)]
        public long SizeInBytes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encoding { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AssociationInfo 
    {
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AssociationBody 
    {
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ChildAssociationInfo 
    {
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isPrimary", Required = Newtonsoft.Json.Required.Always)]
        public bool IsPrimary { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ChildAssociationBody 
    {
        [Newtonsoft.Json.JsonProperty("childId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ChildId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PathElement 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PathInfo 
    {
        [Newtonsoft.Json.JsonProperty("elements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PathElement> Elements { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isComplete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsComplete { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PermissionElement 
    {
        [Newtonsoft.Json.JsonProperty("authorityId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthorityId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("accessStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PermissionElementAccessStatus? AccessStatus { get; set; } = AlfrescoClient.AlfrescoCore.PermissionElementAccessStatus.ALLOWED;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PermissionsInfo 
    {
        [Newtonsoft.Json.JsonProperty("isInheritanceEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsInheritanceEnabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("inherited", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PermissionElement> Inherited { get; set; }
    
        [Newtonsoft.Json.JsonProperty("locallySet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PermissionElement> LocallySet { get; set; }
    
        [Newtonsoft.Json.JsonProperty("settable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Settable { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PermissionsBody 
    {
        [Newtonsoft.Json.JsonProperty("isInheritanceEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsInheritanceEnabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("locallySet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PermissionElement> LocallySet { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeBodyCreate 
    {
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |.
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NodeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PermissionsBody Permissions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("relativePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RelativePath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("association", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Association2 Association { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secondaryChildren", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ChildAssociationBody> SecondaryChildren { get; set; }
    
        [Newtonsoft.Json.JsonProperty("targets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AssociationBody> Targets { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeBodyUpdate 
    {
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |.
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PermissionsBody Permissions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeBodyCopy 
    {
        [Newtonsoft.Json.JsonProperty("targetParentId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetParentId { get; set; }
    
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |.
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeBodyMove 
    {
        [Newtonsoft.Json.JsonProperty("targetParentId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetParentId { get; set; }
    
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |.
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeBodyLock 
    {
        [Newtonsoft.Json.JsonProperty("timeToExpire", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int? TimeToExpire { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NodeBodyLockType? Type { get; set; } = AlfrescoClient.AlfrescoCore.NodeBodyLockType.ALLOW_OWNER_CHANGES;
    
        [Newtonsoft.Json.JsonProperty("lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NodeBodyLockLifetime? Lifetime { get; set; } = AlfrescoClient.AlfrescoCore.NodeBodyLockLifetime.PERSISTENT;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodePaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List17 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeAssociationPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List18 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeChildAssociationPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List19 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeAssociationEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public NodeAssociation Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeAssociation : Node
    {
        [Newtonsoft.Json.JsonProperty("association", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AssociationInfo Association { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeChildAssociationEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public NodeChildAssociation Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeChildAssociation : Node
    {
        [Newtonsoft.Json.JsonProperty("association", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ChildAssociationInfo Association { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AssociationEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Association Entry { get; set; } = new Association();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Association 
    {
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ChildAssociationEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ChildAssociation Entry { get; set; } = new ChildAssociation();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ChildAssociation 
    {
        [Newtonsoft.Json.JsonProperty("childId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ChildId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class NodeEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Node Entry { get; set; } = new Node();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Node 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |.
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NodeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFolder", Required = Newtonsoft.Json.Required.Always)]
        public bool IsFolder { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFile", Required = Newtonsoft.Json.Required.Always)]
        public bool IsFile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isLocked", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsLocked { get; set; } = false;
    
        [Newtonsoft.Json.JsonProperty("modifiedAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ModifiedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedByUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserInfo ModifiedByUser { get; set; } = new UserInfo();
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdByUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserInfo CreatedByUser { get; set; } = new UserInfo();
    
        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParentId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsLink { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFavorite", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsFavorite { get; set; }
    
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContentInfo Content { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("allowableOperations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AllowableOperations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PathInfo Path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PermissionsInfo Permissions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ProbeEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Entry Entry { get; set; } = new Entry();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SharedLinkBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("nodeId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NodeId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpiresAt { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SharedLinkBodyEmail 
    {
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Client { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Locale { get; set; }
    
        [Newtonsoft.Json.JsonProperty("recipientEmails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> RecipientEmails { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SharedLinkPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public List20 List { get; set; } = new List20();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SharedLinkEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SharedLink Entry { get; set; } = new SharedLink();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class SharedLink 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("expiresAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpiresAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeId { get; set; }
    
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |. 
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ModifiedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedByUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserInfo ModifiedByUser { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sharedByUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserInfo SharedByUser { get; set; }
    
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContentInfo Content { get; set; }
    
        /// <summary>The allowable operations for the Quickshare link itself. See allowableOperationsOnTarget for the
        /// allowable operations pertaining to the linked content node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowableOperations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AllowableOperations { get; set; }
    
        /// <summary>The allowable operations for the content node being shared.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowableOperationsOnTarget", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AllowableOperationsOnTarget { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFavorite", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsFavorite { get; set; }
    
        /// <summary>A subset of the target node's properties, system properties and properties already available in the SharedLink are excluded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RenditionBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RenditionEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Rendition Entry { get; set; } = new Rendition();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Rendition 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContentInfo Content { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RenditionStatus? Status { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RenditionPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List21 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DeletedNodesPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List22 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DeletedNodeEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DeletedNode Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DeletedNode : Node
    {
        [Newtonsoft.Json.JsonProperty("archivedByUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserInfo ArchivedByUser { get; set; } = new UserInfo();
    
        [Newtonsoft.Json.JsonProperty("archivedAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ArchivedAt { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DeletedNodeBodyRestore 
    {
        [Newtonsoft.Json.JsonProperty("targetParentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetParentId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class RevertBody 
    {
        [Newtonsoft.Json.JsonProperty("majorVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? MajorVersion { get; set; }
    
        [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Comment { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class VersionPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List23 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class VersionEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Version Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Version 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("versionComment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VersionComment { get; set; }
    
        /// <summary>The name must not contain spaces or the following special characters: * " &lt; &gt; \ / ? : and |. 
        /// The character . must not be used at the end of the name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(?!(.*[\""\*\\\>\<\?\/\:\|]+.*)|(.*[\.]?.*[\.]+$)|(.*[ ]+$))")]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NodeType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFolder", Required = Newtonsoft.Json.Required.Always)]
        public bool IsFolder { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isFile", Required = Newtonsoft.Json.Required.Always)]
        public bool IsFile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ModifiedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("modifiedByUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserInfo ModifiedByUser { get; set; } = new UserInfo();
    
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContentInfo Content { get; set; }
    
        [Newtonsoft.Json.JsonProperty("aspectNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AspectNames { get; set; }
    
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Properties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DownloadBodyCreate 
    {
        [Newtonsoft.Json.JsonProperty("nodeIds", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> NodeIds { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class DownloadEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Download Entry { get; set; } = new Download();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Download 
    {
        /// <summary>number of files added so far in the zip</summary>
        [Newtonsoft.Json.JsonProperty("filesAdded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FilesAdded { get; set; }
    
        /// <summary>number of bytes added so far in the zip</summary>
        [Newtonsoft.Json.JsonProperty("bytesAdded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BytesAdded { get; set; }
    
        /// <summary>the id of the download node</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>the total number of files to be added in the zip</summary>
        [Newtonsoft.Json.JsonProperty("totalFiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TotalFiles { get; set; }
    
        /// <summary>the total number of bytes to be added in the zip</summary>
        [Newtonsoft.Json.JsonProperty("totalBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TotalBytes { get; set; }
    
        /// <summary>the current status of the download node creation</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DownloadStatus? Status { get; set; } = AlfrescoClient.AlfrescoCore.DownloadStatus.PENDING;
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ClientBody 
    {
        /// <summary>the client name</summary>
        [Newtonsoft.Json.JsonProperty("client", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Client { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class PasswordResetBody 
    {
        /// <summary>the new password</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }
    
        /// <summary>the workflow id provided in the reset password email</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        /// <summary>the workflow key provided in the reset password email</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditAppPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List24 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditAppEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuditApp Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditApp 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsEnabled { get; set; } = true;
    
        [Newtonsoft.Json.JsonProperty("maxEntryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxEntryId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("minEntryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinEntryId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditBodyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("isEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsEnabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditEntryPaging 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List25 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditEntryEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuditEntry Entry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class AuditEntry 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("auditApplicationId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuditApplicationId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("createdByUser", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public UserInfo CreatedByUser { get; set; } = new UserInfo();
    
        [Newtonsoft.Json.JsonProperty("createdAt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreatedAt { get; set; }
    
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Values { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionDefinitionList 
    {
        [Newtonsoft.Json.JsonProperty("list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public List26 List { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionDefinitionEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ActionDefinition Entry { get; set; } = new ActionDefinition();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionDefinition 
    {
        /// <summary>Identifier of the action definition — used for example when executing an action</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
        /// <summary>name of the action definition, e.g. "move"</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>title of the action definition, e.g. "Move"</summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Title { get; set; }
    
        /// <summary>describes the action definition, e.g. "This will move the matched item to another space."</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>QNames of the types this action applies to</summary>
        [Newtonsoft.Json.JsonProperty("applicableTypes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> ApplicableTypes { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>whether the basic action definition supports action tracking or not</summary>
        [Newtonsoft.Json.JsonProperty("trackStatus", Required = Newtonsoft.Json.Required.Always)]
        public bool TrackStatus { get; set; }
    
        [Newtonsoft.Json.JsonProperty("parameterDefinitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ActionParameterDefinition> ParameterDefinitions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionParameterDefinition 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("multiValued", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? MultiValued { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mandatory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Mandatory { get; set; }
    
        [Newtonsoft.Json.JsonProperty("displayLabel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayLabel { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionBodyExec 
    {
        [Newtonsoft.Json.JsonProperty("actionDefinitionId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ActionDefinitionId { get; set; }
    
        /// <summary>The entity upon which to execute the action, typically a node ID or similar.</summary>
        [Newtonsoft.Json.JsonProperty("targetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Params { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionExecResultEntry 
    {
        [Newtonsoft.Json.JsonProperty("entry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ActionExecResult Entry { get; set; } = new ActionExecResult();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class ActionExecResult 
    {
        /// <summary>The unique identifier of the action pending execution</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Error1 
    {
        [Newtonsoft.Json.JsonProperty("errorKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorKey { get; set; }
    
        [Newtonsoft.Json.JsonProperty("statusCode", Required = Newtonsoft.Json.Required.Always)]
        public int StatusCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("briefSummary", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BriefSummary { get; set; }
    
        [Newtonsoft.Json.JsonProperty("stackTrace", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string StackTrace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("descriptionURL", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DescriptionURL { get; set; }
    
        [Newtonsoft.Json.JsonProperty("logId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LogId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteBodyCreateVisibility
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC")]
        PUBLIC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PRIVATE")]
        PRIVATE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATED")]
        MODERATED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteVisibility
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRIVATE")]
        PRIVATE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATED")]
        MODERATED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC")]
        PUBLIC = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteRole2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SiteConsumer")]
        SiteConsumer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteCollaborator")]
        SiteCollaborator = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteContributor")]
        SiteContributor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteManager")]
        SiteManager = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteBodyUpdateVisibility
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRIVATE")]
        PRIVATE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MODERATED")]
        MODERATED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PUBLIC")]
        PUBLIC = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List2 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteContainerEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteContainerEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteMembershipBodyCreateRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SiteConsumer")]
        SiteConsumer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteCollaborator")]
        SiteCollaborator = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteContributor")]
        SiteContributor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteManager")]
        SiteManager = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteMembershipBodyUpdateRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SiteConsumer")]
        SiteConsumer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteCollaborator")]
        SiteCollaborator = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteContributor")]
        SiteContributor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteManager")]
        SiteManager = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List3 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteMemberEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteMemberEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteMemberRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SiteConsumer")]
        SiteConsumer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteCollaborator")]
        SiteCollaborator = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteContributor")]
        SiteContributor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteManager")]
        SiteManager = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List4 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteRoleEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteRoleEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum SiteRoleRole
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SiteConsumer")]
        SiteConsumer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteCollaborator")]
        SiteCollaborator = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteContributor")]
        SiteContributor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SiteManager")]
        SiteManager = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List5 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PersonEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List6 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GroupEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List7 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<GroupMemberEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum GroupMemberMemberType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP")]
        GROUP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSON")]
        PERSON = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum GroupMembershipBodyCreateMemberType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GROUP")]
        GROUP = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERSON")]
        PERSON = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List8 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CommentEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<CommentEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List9 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TagEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<TagEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List10 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PersonNetworkEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<PersonNetworkEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum PersonNetworkSubscriptionLevel
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Free")]
        Free = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Enterprise")]
        Enterprise = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum RatingBodyId
    {
        [System.Runtime.Serialization.EnumMember(Value = @"likes")]
        Likes = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"fiveStar")]
        FiveStar = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List11 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RatingEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<RatingEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Aggregate 
    {
        [Newtonsoft.Json.JsonProperty("numberOfRatings", Required = Newtonsoft.Json.Required.Always)]
        public int NumberOfRatings { get; set; }
    
        [Newtonsoft.Json.JsonProperty("average", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Average { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List12 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FavoriteEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<FavoriteEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List13 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ActivityEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<ActivityEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List14 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PreferenceEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<PreferenceEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List15 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteMembershipRequestEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteMembershipRequestEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List16 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SiteMembershipRequestWithPersonEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SiteMembershipRequestWithPersonEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum PermissionElementAccessStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOWED")]
        ALLOWED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENIED")]
        DENIED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Association2 
    {
        [Newtonsoft.Json.JsonProperty("assocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AssocType { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum NodeBodyLockType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ALLOW_OWNER_CHANGES")]
        ALLOW_OWNER_CHANGES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FULL")]
        FULL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum NodeBodyLockLifetime
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERSISTENT")]
        PERSISTENT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EPHEMERAL")]
        EPHEMERAL = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List17 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NodeEntry> Entries { get; set; }
    
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Node Source { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List18 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NodeAssociationEntry> Entries { get; set; }
    
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Node Source { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List19 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NodeChildAssociationEntry> Entries { get; set; }
    
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Node Source { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class Entry 
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List20 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Pagination Pagination { get; set; } = new Pagination();
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SharedLinkEntry> Entries { get; set; } = new System.Collections.ObjectModel.Collection<SharedLinkEntry>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum RenditionStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CREATED")]
        CREATED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_CREATED")]
        NOT_CREATED = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List21 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RenditionEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List22 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DeletedNodeEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List23 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VersionEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum DownloadStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELLED")]
        CANCELLED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DONE")]
        DONE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MAX_CONTENT_SIZE_EXCEEDED")]
        MAX_CONTENT_SIZE_EXCEEDED = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List24 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AuditAppEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List25 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AuditEntryEntry> Entries { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v9.0.0.0)")]
    public partial class List26 
    {
        [Newtonsoft.Json.JsonProperty("pagination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pagination Pagination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("entries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ActionDefinition> Entries { get; set; }
    
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client; 
        private System.IDisposable _response; 

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode; 
            Headers = headers; 
            Stream = stream; 
            _client = client; 
            _response = response;
        }

        public void Dispose() 
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108